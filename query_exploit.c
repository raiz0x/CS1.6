#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <unistd.h> /* close() */
#include <string.h> /* memset() */
#include <time.h>
#include <stdlib.h>

#define MAX_MSG 1000
#define MAX_RESPONSE 4096

#define MIN(a, b) (int) (a < b ? a:b)

char *InfoCache;
int InfoCacheLen, InfoQueries, OtherQueries;
time_t lastQuery, lastfrom;

void query(char *ServerIp, char *ServerPort, char *Query, int QueryLen, char *Response, int ResponseSize, int *ResponseLen) {
   int sd, rc, cliLen;
   struct sockaddr_in cliAddr, remoteServAddr;
   struct hostent *h;
   
   /* get server IP address (no check if input is IP address or DNS name */
   h = gethostbyname(ServerIp);

   remoteServAddr.sin_family = h->h_addrtype;
   memcpy((char *) &remoteServAddr.sin_addr.s_addr,
    h->h_addr_list[0], h->h_length);
   remoteServAddr.sin_port = htons(atoi(ServerPort));
   
   /* socket creation */
   sd = socket(AF_INET,SOCK_DGRAM,0);
   if(sd<0) {
      printf("%s: cannot open socket\n", ServerIp);
      exit(1);
   }
    
   /* bind any port */
   cliAddr.sin_family = AF_INET;
   cliAddr.sin_addr.s_addr = htonl(INADDR_ANY);
   cliAddr.sin_port = htons(0);
      
   rc = bind(sd, (struct sockaddr *) &cliAddr, sizeof(cliAddr));
   if(rc<0) {
      printf("%s: cannot bind port %s\n", ServerIp, ServerPort);
      close(sd);
      exit(1);  
   }

   rc = sendto(sd, Query, QueryLen, 0,
                (struct sockaddr *) &remoteServAddr,
                sizeof(remoteServAddr));

   if(rc<0) {
        printf("%s: cannot send data to remote server\n", ServerIp);
   }

   struct timeval timeout;
   timeout.tv_sec = 3;
   timeout.tv_usec = 0;
   setsockopt(sd, SOL_SOCKET, SO_RCVTIMEO, (struct timeval*)&timeout, sizeof(timeout));

   cliLen = sizeof(cliAddr);
   (*ResponseLen) = recvfrom(sd, Response, ResponseSize , 0,
       (struct sockaddr *) &cliAddr, &cliLen);

   close(sd);
}
int main(int argc, char *argv[]) {
   
   int sd, rc, cliLen;
   struct sockaddr_in cliAddr, servAddr;
   char msg[MAX_MSG],response[MAX_MSG];
   int msglen,responselen;
   
   if (argc != 4) {
     fprintf(stderr, "usage: %s <proxy port> <gameserver ip> <gameserver port>\n", argv[0]);
     exit(1);
   }
   
   /* Init info cache buffer */            
   InfoCache = (char *)malloc(MAX_MSG);

   /* socket creation */
   sd=socket(AF_INET, SOCK_DGRAM, 0);
   if(sd<0) {
      printf("%s: cannot open socket3 \n",argv[0]);
      exit(1);
   }

   /* bind local server port */
   servAddr.sin_family = AF_INET;
   servAddr.sin_addr.s_addr = htonl(INADDR_ANY);
   servAddr.sin_port = htons(atoi(argv[1]));
   rc = bind (sd, (struct sockaddr *) &servAddr,sizeof(servAddr));
   if(rc<0) {
      printf("%s: cannot bind port number: %s \n", argv[0], argv[1]);
      exit(1);
   }

   printf("%s: waiting for data on port UDP %s\n",
       argv[0],argv[1]);

   lastfrom = time(NULL);
   
   /* server infinite loop */
   while(1) {
      
      /* init buffer */
      memset(msg,0x0,MAX_MSG);

      /* receive message */
      cliLen = sizeof(cliAddr);
      msglen = recvfrom(sd, msg, MAX_MSG, 0,
       (struct sockaddr *) &cliAddr, &cliLen);
       
      if ( msglen > 4 && msg[4] == 0x54 ) {
        InfoQueries++;
        /* info query, check cache */
        if ( lastQuery + 5 < time(NULL) ) {
          query(argv[2], argv[3], msg, msglen, InfoCache, MAX_MSG, &InfoCacheLen);
          lastQuery = time(NULL);
        }
        rc = sendto(sd, InfoCache, InfoCacheLen, 0,
		(struct sockaddr *) &cliAddr,
		cliLen);
      } else {
        OtherQueries++;

        /* not an info query */
        /*
        switch( msg[4] ) {
          case 0x55:
            printf("PLAYERLIST[%s:%u]\n", inet_ntoa(cliAddr.sin_addr), ntohs(cliAddr.sin_port));
            break;
          case 0x56:
            printf("RULES[%s:%u]\n", inet_ntoa(cliAddr.sin_addr), ntohs(cliAddr.sin_port));
            break;
          case 0x57:
            printf("GETCHALLENGE[%s:%u]\n", inet_ntoa(cliAddr.sin_addr), ntohs(cliAddr.sin_port));
            break;
          default:
            printf("OTHER[%s:%u][%x]=%s, len=%d\n", inet_ntoa(cliAddr.sin_addr), ntohs(cliAddr.sin_port), msg[4], msg, msglen);
        }*/
        
        query(argv[2], argv[3], msg, msglen, response, MAX_MSG, &responselen);
        rc = sendto(sd, response, responselen, 0,
		(struct sockaddr *) &cliAddr,
		cliLen);      
      }
      
      if ( lastfrom + 10 <= time(NULL) ) {
        printf("Got %d info queries and %d other queries in last %d seconds\n", InfoQueries, OtherQueries, (int)(time(NULL)-lastfrom));
        InfoQueries = 0;
        OtherQueries = 0;
        lastfrom = time(NULL);
      }
   }/* end of server infinite loop */
   
   return 0;
}
