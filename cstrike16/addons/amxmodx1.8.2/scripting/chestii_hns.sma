/* Plugin generated by AMXX-Studio */

#include < amxmodx >
#include < cstrike >
#include < fun >
#include < hamsandwich >
#include < colorchat >
#include <engine>
#include <fakemeta>
#include <amxmisc>
#include <fakemeta_util>
#include < nvault >
//#include < CC_ColorChat >

static const
ServerLicensedIp[ ] = "89.40.233.28:27015";

#if cellbits == 32
#define OFFSET_CSMONEY  115
#else
#define OFFSET_CSMONEY  140
#endif
#define OFFSET_LINUX      5

new MODE,REG_HEALTH, MAXHEALTH, COSTS,SHOUT, MESSAGE, COOLDOWN
new PlayerReload[33]

#define TAG "[HNS.PLAY-ARENA.RO]" // > HNS.

#define MAX_ENTITYS 900+15*32

new bool:g_bPlayerInvisible[33];
new bool:g_bWaterInvisible[33];

new bool:g_bWaterEntity[MAX_ENTITYS];
new bool:g_bWaterFound;

new g_iSpectatedId[33];

#define ADMIN_ACCESS ADMIN_IMMUNITY

new cvar_on, cvar_dead

new bool:g_knife[33];

#define COMMAND_ACCESS  	ADMIN_KICK // accesu adminilor pt comanda

#if AMXX_VERSION_NUM < 183
#define MAX_PLAYERS 32
#else
#if MAX_PLAYERS != 32
#define MAX_PLAYERS 32
#endif
#endif

enum
{
	INFO_NAME,
	INFO_IP,
	INFO_AUTHID
};

new const bars[ ] = "/";

new command[ ] [ ] = 
{
	"/gag", 
	"/ungag"
};

new Caccess[ ] = 
{
	COMMAND_ACCESS,
	COMMAND_ACCESS
};

new const gGagTag[ ] = "Gag#";
new const gGagFileName[ ] = "gag_words.ini";
new const gLogFileName[ ] = "GagLog.log"; 

new const gGagThinkerClassname[ ] = "GagThinker_";
new const gGagVaultName[ ] = "GaggedPlayers";

new const gGaggedSound[ ] = "misc/gag_dat.wav";
new const gUnGaggedSound[ ] = "misc/gag_scos.wav";

new const gHalfLifeGaggedSounds[ ][ ] =
{
	"barney/youtalkmuch.wav",
	"scientist/stopasking.wav",
	"scientist/shutup.wav",
	"scientist/shutup2.wav",
	"hgrunt/silence!.wav"
};

new PlayerGagged[ MAX_PLAYERS ];
new PlayerGagTime[ MAX_PLAYERS ];
new JoinTime[ MAX_PLAYERS ];
new szName[ MAX_PLAYERS ], g_reason[ 32 ];

new g_Words[ 562 ] [ 32 ], g_Count;
new szOldName[ MAX_PLAYERS ] [ 40 ];

new gCvarSwearGagTime;
new gCvarGagMinuteLimit;
new gCvarGagMinuteInSeconds;
new gCvarAdminGag;
new gCvarTagName;
new gCvarWords;
new gCvarTag;

new gMaxPlayers;
new gVault;

public plugin_init ( )
{
	new szIp[ 25 ], szPluginName[ 32 ]; // IP>20 | 22
	get_user_ip( 0, szIp, sizeof( szIp ) -1/*, 1*/ ); // charsmax fara -1 / , 0 (cu port) in loc de sizeof
	
	if( equal( szIp, ServerLicensedIp ) ) // contain? in loc de equal
	{
		register_event ( "CurWeapon", "current_weapon", "be", "1=1" );
		
		register_clcmd( "say /invis", "menuInvisDisplay" );
		register_menucmd( register_menuid( "\r[\yHNS.PLAY-ARENA.RO\r] \w- Invizibilitate \y[\rFPS\y]^n^n" ), 1023, "menuInvisAction" );
		
		register_forward( FM_AddToFullPack, "fwdAddToFullPack_Post", 1 );
		RegisterHam( Ham_Spawn, "player", "hamSpawnPlayer_Post", 1 );
		
		register_event( "SpecHealth2", "eventSpecHealth2", "bd" );
		
		register_concmd( "amx_spec", "swap_team", ADMIN_SLAY, "[ Nume Jucator ]" )
		register_concmd( "amx_t", "swap_team", ADMIN_SLAY, "[ Nume Jucator ]" )
		register_concmd( "amx_ct", "swap_team", ADMIN_SLAY, "[ Nume Jucator ]" )
		
		register_clcmd("say /resetscore", "cmdReset");
		register_clcmd("say /rs", "cmdReset");
		register_clcmd("say_team /resetscore", "cmdReset");
		register_clcmd("resetscore", "cmdReset");
		
		register_concmd("amx_resetscore", "conReset", ADMIN_IMMUNITY, "- reseteaza scorul tuturor");
		
		cvar_on = register_cvar("amx_reset_plugin", "1");
		cvar_dead = register_cvar("amx_reset_dead","1");
		
		/* Register CVARs */
		MODE = register_cvar("medic_enabled","1")				/* Mode 1: On ;; Mode 0: Off */	
		REG_HEALTH = register_cvar("medic_health","50")				// How many Health you get instantly?
		
		MAXHEALTH = register_cvar("medic_maxhp","101")				// Maximal HP for everyone	
		COSTS = register_cvar("medic_costs","1")				// How many costs medic?
		SHOUT = register_cvar("medic_shout","1")				// Shout Medic if you buy medic?
		MESSAGE = register_cvar("medic_message","0")				// Write a Message if you buy medic?
		COOLDOWN = register_cvar("medic_cooldown","10")				// Cooldown-Time in Seconds
		
		/* Register Commands */
		register_clcmd("/medic","call_medic",ADMIN_ALL)
		register_clcmd("medic","call_medic",ADMIN_ALL)
		register_clcmd("say /medic","call_medic",ADMIN_ALL)
		register_clcmd("say medic","call_medic",ADMIN_ALL)
		register_clcmd("say_team /medic","call_medic",ADMIN_ALL)
		register_clcmd("say_team medic","call_medic",ADMIN_ALL)
		
		
		register_clcmd("say /knife", "no_knife")
		
		
		register_concmd( "amx_gag", "CommandGag" ); 
		register_concmd( "amx_ungag", "CommandUngag" );
		
		register_clcmd( "say", "CheckGag" );
		register_clcmd( "say_team", "CheckGag" );
		
		register_clcmd( "say", "command_chat" );
		
		GagThinker( );
		register_think( gGagThinkerClassname, "Forward_GagThinker" );
		
		gCvarSwearGagTime = register_cvar( "amx_autogag_time", "1" ); // minutele pt gag cand ia autogag
		gCvarGagMinuteLimit = register_cvar( "amx_gag_minute_limit", "9999" ); // limita maxima pentru gag minute
		gCvarGagMinuteInSeconds = register_cvar( "amx_gag_minute_in_seconds", "60" ); // minute in secunde
		gCvarTagName = register_cvar( "amx_gag_tagname", "0" ); // pune taguri la gag
		gCvarAdminGag = register_cvar( "amx_admingag", "1" ); // poti da si la admini gag daca e egal cu 1, daca e 0 nu poti
		gCvarWords = register_cvar( "amx_maxwords", "200" ); // lista maxima de cuvinte in gag_words.ini
		gCvarTag = register_cvar( "amx_gagtag", "" ); // tag-ul din chat
		
		gMaxPlayers = get_maxplayers( );
		
		formatex( szPluginName, sizeof( szPluginName ) -1, "[>> IP Licentiat <<] M-PLG" );
		register_plugin( szPluginName, "0.0.1X", "raiz0" );
		server_print( "[ %s ] IP-ul serverului este licentiat ! Pluginul va functiona perfect !", "M-PLG" );
		server_print( "[ %s ] Pentru mai multe detalii add Y!M: mafiotiio@yahoo.com ( %s ) !", "M-PLG", "raiz0" );
		server_print( "[ %s ] IP-ul Corespunzator: %s | Ip-ul Serverului: %s | AUTHOR: %s", "M-PLG", ServerLicensedIp, szIp, "raiz0" );
	}
	
	else
	{
		formatex( szPluginName, sizeof( szPluginName ) -1, "[>> IP Nelicentiat <<] M-PLG" );
		register_plugin( szPluginName, "0.0.1X", "raiz0" );
		server_print( "[ %s ] Nu detii o licenta valabila ! Plugin-ul nu va functiona pe acest server !", "M-PLG" );
		server_print( "[ %s ] Pentru mai multe detalii add Y!M: florynboss54 ( %s ) !", "M-PLG", "raiz0" );
		server_print( "[ %s ] IP-ul Corespunzator: %s | IP-ul Serverului: %s | AUTHOR: %s", "M-PLG", ServerLicensedIp, szIp, "raiz0" );
		
		pause( "ade" );
	}
}

public plugin_precache() {
	precache_sound("medic.wav")
	
	new i;
	for( i = 0; i < sizeof gHalfLifeGaggedSounds; i++ )
	{
		precache_sound( gHalfLifeGaggedSounds[ i ] );
	}
	
	precache_sound( gGaggedSound );
	precache_sound( gUnGaggedSound );
}

public plugin_cfg( ) 
{
	new ent = -1;
	while( ( ent = find_ent_by_class( ent, "func_water" ) ) != 0 )
	{
		//       pev( ent, pev_skin ) ==  CONTENTS_WATER is also true on func_water entities
		
		if( !g_bWaterFound )
		{
			g_bWaterFound = true;
		}
		
		g_bWaterEntity[ent] = true;
	}
	
	ent = -1;
	while( ( ent = find_ent_by_class( ent, "func_illusionary" ) ) != 0 )
	{
		if( pev( ent, pev_skin ) ==  CONTENTS_WATER )
		{
			if( !g_bWaterFound )
			{
				g_bWaterFound = true;
			}
			
			g_bWaterEntity[ent] = true;
		}
	}
	
	ent = -1;
	while( ( ent = find_ent_by_class( ent, "func_conveyor" ) ) != 0 )
	{
		if( pev( ent, pev_spawnflags ) == 3 )
		{
			if( !g_bWaterFound )
			{
				g_bWaterFound = true;
			}
			
			g_bWaterEntity[ent] = true;
		}
	}
	
	
	
	static szConfigDir[ 64 ], iFile[ 64 ];
	
	get_localinfo ( "amxx_configsdir", szConfigDir, 63 );
	formatex ( iFile , charsmax( iFile ) , "%s/%s" , szConfigDir, gGagFileName );
	
	if( !file_exists( iFile ) )
	{
		write_file( iFile, "# Pune aici cuvintele jignitoare sau reclamele", -1 );
		log_to_file( gLogFileName, "Fisierul <%s> nu exista! Creez unul nou acum...", iFile );
	}
	
	new szBuffer[ 128 ];
	new szFile = fopen( iFile, "rt" );
	
	while( !feof( szFile ) )
	{
		fgets( szFile, szBuffer, charsmax( szBuffer ) );
		
		if( szBuffer[ 0 ] == '#' )
		{
			continue;
		}
		
		parse( szBuffer, g_Words[ g_Count ], sizeof g_Words[ ] - 1 );
		g_Count++;
		
		if( g_Count >= get_pcvar_num ( gCvarWords ) )
		{
			break;
		}
	}
	
	fclose( szFile );
}

public client_connect ( id )
{
	PlayerReload[id] = 0
	
	LoadGag( id );
}

public client_disconnected ( id )
{
	g_bPlayerInvisible[id] = false;
	g_bWaterInvisible[id] = false;
	g_iSpectatedId[id] = 0;
	
	PlayerReload[id] = 0
	
	g_knife[id] = false
	
	if ( PlayerGagged[ id ] == 1 )
		{	
		ColorChat( 0, RED, "^4%s^1 Jucatorul cu gag^4 %s^1(^3%s^1|^3%s^1), s-a deconectat!", get_tag( ), GetInfo( id, INFO_NAME ), GetInfo( id, INFO_IP ), GetInfo( id, INFO_AUTHID ) );
		log_to_file( gLogFileName, "[HNS.PLAY-ARENA.RO]Jucatorul cu gag <%s><%s><%s>, s-a deconectat!", GetInfo( id, INFO_NAME ), GetInfo( id, INFO_IP ), GetInfo( id, INFO_AUTHID ) );
	}
	
	JoinTime[ id ] = 0 ;
	SaveGag( id );
}


public client_putinserver ( id )
{
//	set_task ( 7.5 , "menuInvisDisplay" , id );
	
	g_knife[id] = false
	
	if ( is_user_connected( id ) )
		{
		JoinTime[ id ] = get_systime( );
	}
}

public fwdAddToFullPack_Post( es_handle, e, ent, host, hostflags, player, pset )
{
	if( player && g_bPlayerInvisible[host] && host != ent && ent != g_iSpectatedId[host] && get_user_team(host) == get_user_team(ent) )
	{
		static const Float:corner[8][3] = 
		{
			{ -4096.0, -4096.0, -4096.0 },
			{ -4096.0, -4096.0, 4096.0 },
			{ -4096.0, 4096.0, -4096.0 },
			{ -4096.0, 4096.0, 4096.0 },
			{ 4096.0, -4096.0, -4096.0 },
			{ 4096.0, -4096.0, 4096.0 },
			{ 4096.0, 4096.0, -4096.0 },
			{ 4096.0, 4096.0, 4096.0 }
		};
		
		static const Float:map_distance = 7094.480108;
		
		static Float:origin[3];
		get_es( es_handle, ES_Origin, origin );
		
		static i;
		while( get_distance_f( origin, corner[i] ) > map_distance )
		{ 
			if( ++i >= sizeof( corner ) )
			{
				i = 0;
			}
		}
		
		set_es( es_handle, ES_Origin, corner[i] );
		set_es( es_handle, ES_Effects, get_es( es_handle, ES_Effects ) | EF_NODRAW );
	}
	else if( g_bWaterInvisible[host] && g_bWaterEntity[ent])
	{
		set_es( es_handle, ES_Effects, get_es( es_handle, ES_Effects ) | EF_NODRAW );
	}
}

public hamSpawnPlayer_Post( id )
{
	g_iSpectatedId[id] = 0;
}

public eventSpecHealth2( id )
{
	g_iSpectatedId[id] = read_data( 2 );
}

public menuInvisDisplay( id )
{
	static menu[256];
	
	new len = formatex( menu, 255, "\r[\yHNS.PLAY-ARENA.RO\r] \w- Invizibilitate \y[\rFPS\y]^n^n" );
	
	len += formatex( menu[len], 255 - len, "\r1. \yCoechipieri: \w%s^n", g_bPlayerInvisible[id] ? "invizibili" : "vizibili" );
	
	if( g_bWaterFound )
	{
		len += formatex( menu[len], 255 - len, "\r2. \yApa: \w%s^n", g_bWaterInvisible[id] ? "invizibila" : "vizibila" );
	}
	else
	{
		len += formatex( menu[len], 255 - len, "\r2. \yApa: \rNu exista pe aceasta mapa \w!^n" );
	}
	
	len += formatex( menu[len], 255 - len, "^n\r0. \yIesire" );
	
	show_menu( id, ( 1<<0 | 1<<1 | 1<<9 ), menu, -1 );
	
	return PLUGIN_HANDLED;
}

public menuInvisAction( id, key )
{
	switch( key )
	{
		case 0:
		{
			g_bPlayerInvisible[id] = !g_bPlayerInvisible[id];
			menuInvisDisplay( id );
		}
		case 1:
		{
			if( g_bWaterFound )
			{
				g_bWaterInvisible[id] = !g_bWaterInvisible[id];
			}
			
			menuInvisDisplay( id );
		}
		case 9: show_menu( id, 0, "" );
	}
}


public swap_team( id )
{
	if( !( get_user_flags( id ) & ADMIN_SLAY ) )
	{
		return PLUGIN_HANDLED
	}
	
	new szArg[ 10 ], target[ 32 ], szPlayerName[ 32 ], szAdminName[ 32 ]
	
	read_argv( 0, szArg, 9 )
	read_argv( 1, target, 31 )
	
	new player = cmd_target( id, target, 11 )
	
	if( !player )
	return PLUGIN_HANDLED
	
	get_user_name( player, szPlayerName, 31 )
	get_user_name( id, szAdminName, 31 )
	
	switch( szArg[ 4 ] )
	{
		case 't': 
		{
			if( cs_get_user_team( player ) == CS_TEAM_T )
			{
				client_print( id, print_console, "[ HnS.play-arena.Ro ] Jucatorul este deja la terroristi." )
				return PLUGIN_HANDLED
			}
			else
			{
				user_silentkill( player )
				cs_set_user_team( player, CS_TEAM_T )
				
				chat_colorx( 0, "!n[!gHnS.Play-Arena.Ro!n] [ !t%s!n ] Il transfera pe [ !g%s!n ] la [ !tTero!n ]", szAdminName, szPlayerName )
			}
		}
		
		case 'c': 
		{
			if( cs_get_user_team( player ) == CS_TEAM_CT )
			{
				client_print( id, print_console, "[ HnS.Play-Arena.Ro ] Jucatorul este deja la counter-terroristi." )
				return PLUGIN_HANDLED
			}
			else
			{
				user_silentkill( player )
				cs_set_user_team( player, CS_TEAM_CT )
				chat_colorx( 0, "!n[!gHnS.Play-Arena.Ro!n] [ !t%s!n ] Il transfera pe [ !g%s!n ] la [ !tCt!n ]", szAdminName, szPlayerName )
			}
		}
		
		case 's': 
		{
			if( cs_get_user_team( player ) == CS_TEAM_SPECTATOR )
			{
				client_print( id, print_console, "[ HnS.Play-Arena.Ro ] Jucatorul este deja la spectatori." )
				return PLUGIN_HANDLED
			}
			else
			{
				user_silentkill( player )
				cs_set_user_team( player, CS_TEAM_SPECTATOR )
				chat_colorx( 0, "!n[!gHnS.Play-Arena.Ro!n] [ !t%s!n ] Il transfera pe [ !g%s!n ] la [ !tSpec!n ]", szAdminName, szPlayerName )
			}
		}
	}
	
	return PLUGIN_CONTINUE
}

public cmdReset(id) {
	if(get_pcvar_num(cvar_on) == 0) {
		ColorChat(id, NORMAL,"^4[^1 HnS.Play-Arena.Ro^4 ]^1 Pluginul este^3 dezactivat");
		return PLUGIN_HANDLED;
	}
	if(get_pcvar_num(cvar_dead) == 0 && !is_user_alive(id)) {
		ColorChat(id, NORMAL,"^4[^1 HnS.Play-Arena.Ro^4 ]^1 Poti folosii comanda numai atunci cand esti viu.");
		return PLUGIN_HANDLED;
	}
	
	new frags = get_user_frags(id);
	new deaths = get_user_deaths(id);
	
	if(frags == 0 && deaths == 0)
	ColorChat(id, NORMAL,"^4[^1 HnS.Play-Arena.Ro^4 ]^1 Scorul tau este deja^3 0");
	else {
		for(new i = 0; i < 2; i++) {
			cs_set_user_deaths(id, 0);
			set_user_frags(id, 0);
		}
		
		new name[32];
		get_user_name(id, name, 31);
		
		ColorChat(id, NORMAL,"^4[^1 HnS.Play-Arena.Ro^4 ]^1 Scorul tau s-a^3 Resetat^1.");
		ColorChat(0, NORMAL,"^4[^1 HnS.Play-Arena.Ro^4 ]^3 %s^1 si-a resetat^4 Scorul^1.", name);
	}
	return PLUGIN_HANDLED;
}

public conReset(id) {
	if(get_user_flags(id)&ADMIN_ACCESS) {
		new players[32], num, player;
		get_players(players, num, "c");
		
		for(new i = 0; i < num; i++) {
			player = players[i];
			if(get_user_frags(player) != 0 && get_user_deaths(player) != 0) {
				cs_set_user_deaths(player, 0);
				set_user_frags(player, 0);
			}
		}
		
		new name[32];
		get_user_name(id, name, 31);
		
		ColorChat(0, NORMAL,"^4[^1 HnS.Play-Arena.Ro^4 ]^3 %s^1 a resetat^4 Scorul^3 Tuturor^1.", name);
	}
	else
	console_print(id, "Nu ai acces la aceasta comanda.");
	
	return PLUGIN_HANDLED;
}

public call_medic(id) {
	/* Mods and Stuff */
	if(get_pcvar_num(MODE) == 1 && PlayerReload[id] < time())
	{
		new ActuellHP = get_user_health(id);
		new ActuellMoney = fm_cs_get_user_money(id);
		
		if(ActuellMoney < get_pcvar_num(COSTS))
		{
			ColorChat(id,NORMAL,"^x04%s^x01 Nu ai destui bani, pentru a chema Medicul",TAG)
		}
		else
		{
			if(ActuellHP < get_pcvar_num(MAXHEALTH))
			{
				/* Shout if activated */
				/* Write message if activated */
				new playerCount, i, players[32], name[33];
				get_players(players, playerCount, "ach");
				get_user_name(id,name,32)
				
				for(i=1; i<=playerCount; i++)
				{
					if(get_user_team(id) == get_user_team(i))
					{
						if(get_pcvar_num(MESSAGE) == 1)
						{
							ColorChat(i,NORMAL,"^x04%s^x0  (^x03 RADIO^x01 ):^x04 Medic^x01 !",name)
							
							if(get_pcvar_num(SHOUT) == 1)
							{
								engfunc(EngFunc_EmitSound, i, CHAN_ITEM, "medic.wav", 1.0, ATTN_NORM, 0, PITCH_NORM);
							}
						}						
					}
					
				}
				
				new Float:Lebenplus = get_pcvar_float(REG_HEALTH);
				
				if(ActuellHP + Lebenplus > get_pcvar_num(MAXHEALTH))
				{
					set_pev(id,pev_health,get_pcvar_float(MAXHEALTH))
				}
				else
				{
					set_pev(id,pev_health,ActuellHP + Lebenplus);
				}
				
				PlayerReload[id] = time() + get_pcvar_num(COOLDOWN)		/* Activate Reload */
				fm_cs_set_user_money(id,ActuellMoney-get_pcvar_num(COSTS),1)	/* Pay.. */
				
			}
			else
			{
				ColorChat(id,NORMAL,"^x04%s^x01 Ai deja^x03 %d HP^x01 !",TAG,get_pcvar_num(MAXHEALTH))
			}
			
		}
	}
	else
	{
		if(get_pcvar_num(MODE) != 1)
		ColorChat(id,NORMAL,"^x04%s^x03 Chemarea Medicului^x01 este^x04 DEZACTIVATA^x01 !",TAG)
		else
		{
			new Seconds = PlayerReload[id] - time()
			ColorChat(id,NORMAL,"^x04%s^x01 Prietene, chemi prea des medicul. Asteapta^x03 %i^x01 secunde..",TAG,Seconds)	
		}
	}
	return PLUGIN_HANDLED;
}

stock fm_cs_set_user_money(id,money,flash=1)
{
	set_pdata_int(id,OFFSET_CSMONEY,money,OFFSET_LINUX);
	
	message_begin(MSG_ONE,get_user_msgid("Money"),{0,0,0},id);
	write_long(money);
	write_byte(flash);
	message_end();
}

stock fm_cs_get_user_money(id)
{
	return get_pdata_int(id,OFFSET_CSMONEY,OFFSET_LINUX);
}

public current_weapon(id)
{
	if(!is_user_alive(id))
	{
		return PLUGIN_CONTINUE
	}
	
	if(cs_get_user_team(id) == CS_TEAM_T)
	{
		if(get_user_weapon(id) != CSW_KNIFE)
		{
			return PLUGIN_CONTINUE;
		}
		else
		{
			if(g_knife[id])
			{
				set_pev(id, pev_viewmodel2, "models/v_knife.mdl")
				set_pev(id, pev_weaponmodel2, "models/p_knife.mdl")
			}
			else
			{
				set_pev(id, pev_viewmodel2, "")
				set_pev(id, pev_weaponmodel2, "")
			}
		}
	}
	return PLUGIN_CONTINUE
}

public no_knife(id)
{
	if(is_user_alive(id))
	{
		if(cs_get_user_team(id))
		{
			if(g_knife[id])
			{
				g_knife[id] = false
				ham_strip_user_weapon(id, CSW_KNIFE);
				chat_color(id, ".v[.gHNS.PLAY-ARENA.RO.v].e Cutitul.g a.v Disparut")
				fm_give_item(id, "weapon_knife")
				engclient_cmd(id, "weapon_knife")
			}
			else
			{
				g_knife[id] = true
				ham_strip_user_weapon(id, CSW_KNIFE);
				chat_color(id, ".v[.gHNS.PLAY-ARENA.RO.v].g Acum iti vezi.e Cutitul")
				fm_give_item(id, "weapon_knife")
				engclient_cmd(id, "weapon_knife")
			}
		}
		else
		{
			chat_color(id, ".v[.gHNS.PLAY-ARENA.RO.v].g Esti.e CT.g Nu poti folosi acest.v Meniu.g.")
		}
	}
	else
	{
		chat_color(id, ".v[.gHNS.PLAY-ARENA.RO.v].g Trebuie sa fii in.e Viata.g pentru a folosi aceasta.v Comanda.g.")
	}
}


public command_chat( index )
{
	static szArg[ 192 ], command2[ 192 ];
	
	read_args( szArg, charsmax ( szArg ) );
	
	if( ! szArg [ 0 ] )	return PLUGIN_CONTINUE;
	
	remove_quotes( szArg[0] );
	
	for( new x; x < sizeof command; x++ )
	{
		if ( equal ( szArg, command [ x ], strlen ( command [ x ] ) ) )
			{
			if ( get_user_flags ( index ) & Caccess [ x ] )
				{
				replace( szArg, charsmax ( szArg ), bars, "" );
				formatex( command2, charsmax(command2), "amx_%s", szArg );
				client_cmd( index, command2 );
			}	
			
			break;
		}
	}
	return PLUGIN_CONTINUE;
}

public CheckGag( id ) 
{
	new szSaid[ 300 ];
	
	read_args( szSaid, charsmax( szSaid ) );
	remove_quotes( szSaid );
	
	if( !UTIL_IsValidMessage( szSaid ) )
	{
		return PLUGIN_HANDLED;
	}
	if(!is_user_connected(id))	retrun PLUGIN_HANDLED
	
	if ( PlayerGagged[ id ] == 1 ) 
		{
		PlayerGagged[ id ] = 1;
		
		ColorChat( id, RED, "^4%s^1 Ai primit Gag pentru limbaj vulgar, asteapta^4 %d^1 minute! Motiv^3 %s", get_tag( ), PlayerGagTime[ id ], g_reason );
		client_cmd( id, "speak ^"%s^"", gHalfLifeGaggedSounds[ random_num( 0, charsmax( gHalfLifeGaggedSounds ) ) ] );	
		
		return PLUGIN_HANDLED;
	}
	
	else
	{
		new i;
		for( i = 0; i < get_pcvar_num ( gCvarWords ); i++ )
		{
			if( containi( szSaid, g_Words[ i ] ) != -1 )
			{
				if( get_pcvar_num( gCvarAdminGag ) == 0 )
				{
					if ( is_user_admin ( id ) )
						{	
						return 1;
					}
				}
				
				get_user_name( id, szName, sizeof ( szName ) -1 );
				
				if ( get_pcvar_num( gCvarTagName ) == 1 )
					{
					client_cmd( id, "name ^"%s %s^"", gGagTag, szName );
				}
				
				szOldName[ id ] = szName;
				
				PlayerGagged[ id ] = 1;
				PlayerGagTime[ id ] = get_pcvar_num ( gCvarSwearGagTime );
				set_speak( id, SPEAK_MUTED );
				
				ColorChat( 0, RED, "^3%s^4 %s^1 (^3%s^1)^1 a primit AutoGag pentru limbaj sau reclama!", get_tag( ), GetInfo( id, INFO_NAME ), GetInfo( id, INFO_IP ) );
				ColorChat( id, RED, "^4%s^1 Ai primit AutoGag pentru injuratura sau reclama! Timpul expira in:^4 %d^1 minute!", get_tag( ), PlayerGagTime[ id ] );
				ColorChat( id, RED, "^4%s^1 Nu mai poti folosi urmatoarele comenzi:^4 say^1,^4 say_team^1,^4 voice speak", get_tag( ) );
				
				log_to_file( gLogFileName, "[HNS.PLAY-ARENA.RO]<%s><%s><%s> a luat AutoGag pentru ca a injurat sau a facut reclama!", GetInfo( id, INFO_NAME ), GetInfo( id, INFO_IP ), GetInfo( id, INFO_AUTHID ) );
				client_cmd( id, "speak ^"%s^"", gGaggedSound );
				
				return PLUGIN_HANDLED;
			}
		}
	}
	
	return PLUGIN_CONTINUE;
}

public CommandGag( id )  
{  
	if( !(get_user_flags( id ) & COMMAND_ACCESS ) )
	{
		client_cmd( id, "echo %s Nu ai acces la aceasta comanda!", get_tag( ) );
		return 1;
	}
	if(!is_user_connected(id))	retrun PLUGIN_HANDLED
	
	new szArg[ 32 ], szMinutes[ 32 ];
	
	read_argv( 1, szArg, charsmax ( szArg ) );
	
	new reason[ 32 ];
	read_argv( 3, reason, sizeof reason - 1 );
	
	copy( g_reason, 31, reason );
	//copy( g_admin, 31, GetInfo( id, INFO_NAME ) );
	//copy( g_minutes, 31, szMinutes );
	//remove_quotes( reason );
	
	if( equal( szArg, "" ) )
	{
		client_cmd( id, "echo amx_gag < nume > < minute > < motiv >!" );
		return 1;
	}
	
	new iPlayer = cmd_target( id, szArg, 1 );
	
	if( !iPlayer )
	{
		client_cmd( id, "echo %s Jucatorul specificat nu a fost gasit!", get_tag( ) );
		return 1;
	}
	if(!is_user_connected(iPlayer))	retrun PLUGIN_HANDLED
	
	if ( get_pcvar_num( gCvarAdminGag ) == 0 )
		{
		if ( is_user_admin( iPlayer ) )
			{
			client_cmd( id, "echo %s Nu poti da gag la Admini!", get_tag( ) );
			return 1;
		}
	}
	
	read_argv( 2, szMinutes, charsmax ( szMinutes ) );
	
	new iMinutes = str_to_num( szMinutes );
	
	if ( iMinutes > get_pcvar_num ( gCvarGagMinuteLimit ) )
		{
		console_print( id, "%s Ai setat %d minute, iar limita maxima de minute este %d! Setare automata pe %d.", get_tag( ), iMinutes, get_pcvar_float ( gCvarGagMinuteLimit ), get_pcvar_float ( gCvarGagMinuteLimit ) );
		iMinutes = get_pcvar_num( gCvarGagMinuteLimit ) ;
	}
	
	get_user_name( iPlayer, szName, sizeof ( szName ) -1 );
	
	szOldName[ iPlayer ] = szName;
	
	if( PlayerGagged[ iPlayer ] == 1 ) 
	{
		client_cmd( id, "echo %s Jucatorul %s are deja Gag!", get_tag( ), GetInfo( iPlayer, INFO_NAME ) );
		return 1;
	} 
	
	if ( get_pcvar_num( gCvarTagName ) == 1 )
		{
		client_cmd( iPlayer, "name ^"%s %s^"", gGagTag, szName );
	}
	
	PlayerGagged[ iPlayer ] = 1;
	PlayerGagTime[ iPlayer ] = iMinutes;
	set_speak( iPlayer, SPEAK_MUTED );
	
	ColorChat( 0, RED, "^4%s^1 ADMIN^4 %s:^1 Gag^3 %s^1(^3%s^1) pentru^4 %d^1 minute! Motiv^3 %s", get_tag( ), GetInfo( id, INFO_NAME ), GetInfo( iPlayer, INFO_NAME ), GetInfo( iPlayer, INFO_IP ), iMinutes, reason ); 
	ColorChat( iPlayer, RED, "^4%s^1 Ai primit Gag pentru ca ai injurat sau ai facut reclama!", get_tag( ) ); 
	ColorChat( iPlayer, RED, "^4%s^1 Nu mai poti folosi urmatoarele comenzi:^4 say^1,^4 say_team^1,^4 voice speak", get_tag( ) );
	ColorChat( iPlayer, RED, "^4%s^1 Ai primit gag de la^3 %s^1 pentru^4 %d^1 minute! Motiv^3 %s", get_tag( ), GetInfo( id, INFO_NAME ), iMinutes, reason );
	
	log_to_file( gLogFileName, "[HNS.PLAY-ARENA.RO-GAG]%s i-a dat gag lui <%s><%s><%s> pt. <%d> minute", GetInfo( id, INFO_NAME ), GetInfo( iPlayer, INFO_NAME ), GetInfo( iPlayer, INFO_IP ), GetInfo( iPlayer, INFO_AUTHID ), iMinutes );
	client_cmd( iPlayer, "speak ^"%s^"", gGaggedSound );
	
	return PLUGIN_HANDLED;
}

public CommandUngag( id )  
{  
	if( !(get_user_flags( id ) & COMMAND_ACCESS ) )
	{
		client_cmd( id, "echo %s Nu ai acces la aceasta comanda!", get_tag( ) );
		return 1;
	}
	if(!is_user_connected(id))	retrun PLUGIN_HANDLED
	
	new szArg[ 32 ];
	
	read_argv( 1, szArg, charsmax( szArg ) );
	
	if( equal( szArg, "" ) )
	{
		client_cmd( id, "echo amx_ungag < nume > !" );
		return 1;
	}
	
	new iPlayer = cmd_target ( id, szArg, 8 );
	
	if( !iPlayer )
	{
		client_cmd(  id, "echo %s Jucatorul specificat nu a fost gasit!", get_tag( ) );
		return 1;
	}
	if(!is_user_connected(iPlayer))	retrun PLUGIN_HANDLED
	
	if( PlayerGagged[ iPlayer ] == 0 ) 
	{
		console_print( id, "%s Jucatorul %s nu are Gag!", get_tag( ), GetInfo( iPlayer, INFO_NAME ) );
		return 1;
	}
	
	if ( get_pcvar_num ( gCvarTagName ) == 1 )
		{
		client_cmd( iPlayer, "name ^"%s^"", szOldName[ iPlayer ] );
	}
	
	PlayerGagged[ iPlayer ] = 0;
	PlayerGagTime[ iPlayer ] = 0;
	set_speak( iPlayer, SPEAK_NORMAL );
	
	ColorChat( 0, RED, "^4%s^1 ADMIN^4 %s:^1 Ungag^3 %s^1(^3%s^1|^3%s^1)", get_tag( ), GetInfo( id, INFO_NAME ), GetInfo( iPlayer, INFO_NAME ), GetInfo( iPlayer, INFO_IP ), GetInfo( iPlayer, INFO_AUTHID ) ); 
	ColorChat( iPlayer, RED, "^4%s^1 Ai primit Ungag de la adminul: ^4%s^1, ai grija la limbaj data viitoare!", get_tag( ), GetInfo( id, INFO_NAME ) );
	
	log_to_file( gLogFileName, "[HNS.PLAY-ARENA.RO-UNGAG]<%s> i-a dat ungag lui <%s><%s><%s>", GetInfo( id, INFO_NAME ), GetInfo( iPlayer, INFO_NAME ), GetInfo( iPlayer, INFO_IP ), GetInfo( iPlayer, INFO_AUTHID ) );
	client_cmd( iPlayer, "speak ^"%s^"", gUnGaggedSound );
	
	return PLUGIN_HANDLED;
}

public Forward_GagThinker( iEntity )
{
	if ( pev_valid( iEntity ) )
		{
		set_pev( iEntity, pev_nextthink, get_gametime( ) + 1.0 ) ;
		
		new id;
		for ( id = 1; id <= gMaxPlayers; id++ )
		{
			if ( is_user_connected ( id ) 	
			&& ! is_user_bot( id )
			&& PlayerGagged[ id ] == 1 
			&& PlayerGagTime[ id ] > 0
			&& ( ( get_systime( ) - JoinTime[ id ] ) >= get_pcvar_num ( gCvarGagMinuteInSeconds ) ) )
			{
				JoinTime[ id ] = get_systime( );
				PlayerGagTime[ id ] -= 1;
				
				if ( PlayerGagTime[ id ] <= 0 )
					{
					PlayerGagTime[ id ] = 0;
					PlayerGagged[ id ] = 0;
					set_speak( id, SPEAK_NORMAL );
					
					ColorChat( id, RED, "^4%s^3 Ai primit UnGag, ai grija la limbaj data viitoare!", get_tag( ) );
					log_to_file( gLogFileName, "[HNS.PLAY-ARENA.RO-AUTOUNGAG]<%s> a primit AutoUnGag!", GetInfo( id, INFO_NAME ) );
					
					client_cmd( id, "speak ^"%s^"", gUnGaggedSound );
					client_cmd( id, "name ^"%s^"", szOldName[ id ] );
				}
			}
		}
	}
}

stock SaveGag( id )
{
	gVault = nvault_open( gGagVaultName );
	
	new szIp[ 40 ], szVaultKey[ 64 ], szVaultData[ 64 ];
	get_user_ip( id, szIp, charsmax( szIp ) );
	
	formatex( szVaultKey, charsmax( szVaultKey ), "%s-Gag", szIp );
	formatex( szVaultData, charsmax( szVaultData ), "%i#%i", PlayerGagged[ id ], PlayerGagTime[ id ] );
	
	nvault_set( gVault, szVaultKey, szVaultData );
	nvault_close( gVault );
}

stock LoadGag( id )
{
	gVault = nvault_open( gGagVaultName );
	
	new szIp[ 40 ], szVaultKey[ 64 ], szVaultData[ 64 ];
	get_user_ip( id, szIp, charsmax ( szIp ) );
	
	formatex( szVaultKey, charsmax( szVaultKey ), "%s-Gag", szIp );
	formatex( szVaultData, charsmax( szVaultData ), "%i#%i", PlayerGagged[ id ], PlayerGagTime[ id ] );
	nvault_get( gVault, szVaultKey, szVaultData, charsmax ( szVaultData ) );
	
	replace_all( szVaultData, charsmax( szVaultData ), "#", " " );
	
	new iGagOn[ 32 ], iGagTime [ 32 ];
	parse( szVaultData, iGagOn, charsmax ( iGagOn ), iGagTime, charsmax ( iGagTime ) );
	
	PlayerGagged[ id ] = str_to_num ( iGagOn );
	PlayerGagTime[ id ] = clamp ( str_to_num ( iGagTime ), 0, get_pcvar_num ( gCvarGagMinuteLimit ) );
	
	nvault_close( gVault );
}

stock GagThinker( )
{
	new iEntity = create_entity ( "info_target" );
	
	if( ! pev_valid ( iEntity ) )
	{
		return PLUGIN_HANDLED;
	}
	
	set_pev ( iEntity, pev_classname, gGagThinkerClassname );
	set_pev ( iEntity, pev_nextthink, get_gametime( ) + 1.0 );
	
	return PLUGIN_HANDLED;
}

stock get_tag( )
{
	new szTag [ 65 ];
	get_pcvar_string( gCvarTag, szTag, sizeof ( szTag ) -1 );
	
	return szTag;
}

stock GetInfo( id, const iInfo )
{
	if(!is_user_connected(id))	retrun PLUGIN_HANDLED
	new szInfoToReturn[ 64 ];
	
	switch( iInfo )
	{
		case INFO_NAME:
		{
			new szName[ 32 ];
			get_user_name( id, szName, sizeof ( szName ) -1 );
			
			copy( szInfoToReturn, sizeof ( szInfoToReturn ) -1, szName );
		}
		case INFO_IP:
		{
			new szIp[ 32 ];
			get_user_ip( id, szIp, sizeof ( szIp ) -1, 1 );
			
			copy( szInfoToReturn, sizeof ( szInfoToReturn ) -1, szIp );
		}
		case INFO_AUTHID:
		{
			new szAuthId[ 35 ];
			get_user_authid( id, szAuthId, sizeof ( szAuthId ) -1 );
			
			copy( szInfoToReturn, sizeof ( szInfoToReturn ) -1,  szAuthId );
		}
	}
	
	return szInfoToReturn;
}

stock bool:UTIL_IsValidMessage( const szSaid[ ] )
{
	new iLen = strlen( szSaid );
	
	if( !iLen )
	{
		return false;
	}
	
	for( new i = 0; i < iLen; i++ )
	{
		if( szSaid[ i ] != ' ' )
		{
			return true;
		}
	}
	
	return false;
}

stock chat_color(const id, const input[], any:...)
{
	new count = 1, players[32]
	static msg[191]
	vformat(msg, 190, input, 3)
	
	replace_all(msg, 190, ".v", "^4")
	replace_all(msg, 190, ".g", "^1")
	replace_all(msg, 190, ".e", "^3")
	
	if (id) players[0] = id; else get_players(players, count, "ch")
	{
		for (new i = 0; i < count; i++)
		{
			if (is_user_connected(players[i]))
				{
				message_begin(MSG_ONE_UNRELIABLE, get_user_msgid("SayText"), _, players[i])
				write_byte(players[i]);
				write_string(msg);
				message_end();
			}
		}
	}
}

stock ham_strip_user_weapon(id, iCswId, iSlot = 0, bool:bSwitchIfActive = true)
{
	new iWeapon;
	if(!iSlot)
	{
		static const iWeaponsSlots[] = {
			-1,
			2, //CSW_P228
			-1,
			1, //CSW_SCOUT
			4, //CSW_HEGRENADE
			1, //CSW_XM1014
			5, //CSW_C4
			1, //CSW_MAC10
			1, //CSW_AUG
			4, //CSW_SMOKEGRENADE
			2, //CSW_ELITE
			2, //CSW_FIVESEVEN
			1, //CSW_UMP45
			1, //CSW_SG550
			1, //CSW_GALIL
			1, //CSW_FAMAS
			2, //CSW_USP
			2, //CSW_GLOCK18
			1, //CSW_AWP
			1, //CSW_MP5NAVY
			1, //CSW_M249
			1, //CSW_M3
			1, //CSW_M4A1
			1, //CSW_TMP
			1, //CSW_G3SG1
			4, //CSW_FLASHBANG
			2, //CSW_DEAGLE
			1, //CSW_SG552
			1, //CSW_AK47
			3, //CSW_KNIFE
			1 //CSW_P90
		}
		iSlot = iWeaponsSlots[iCswId];
	}
	
	const XTRA_OFS_PLAYER = 5;
	const m_rgpPlayerItems_Slot0 = 367;
	
	iWeapon = get_pdata_cbase(id, m_rgpPlayerItems_Slot0 + iSlot, XTRA_OFS_PLAYER);
	
	const XTRA_OFS_WEAPON = 4;
	const m_pNext = 42;
	const m_iId = 43;
	
	while(iWeapon > 0)
	{
		if(get_pdata_int(iWeapon, m_iId, XTRA_OFS_WEAPON) == iCswId)
		{
			break;
		}
		iWeapon = get_pdata_cbase(iWeapon, m_pNext, XTRA_OFS_WEAPON);
	}
	if(iWeapon > 0)
	{
		const m_pActiveItem = 373;
		if(bSwitchIfActive && get_pdata_cbase(id, m_pActiveItem, XTRA_OFS_PLAYER) == iWeapon)
		{
			ExecuteHamB(Ham_Weapon_RetireWeapon, iWeapon);
		}
		if(ExecuteHamB(Ham_RemovePlayerItem, id, iWeapon))
		{
			user_has_weapon(id, iCswId, 0);
			ExecuteHamB(Ham_Item_Kill, iWeapon);
			return 1;
		}
	}
	return 0;
}

stock chat_colorx( const id, const input[ ], any:... )
{
	new count = 1, players[ 32 ]
	static msg[ 191 ]
	vformat( msg, 190, input, 3 )
	
	replace_all( msg, 190, "!g", "^4" )
	replace_all( msg, 190, "!n", "^1" )
	replace_all( msg, 190, "!t", "^3" )
	replace_all( msg, 190, "!t2", "^0" )
	
	if( id ) players[ 0 ] = id
	
	else
	get_players( players, count, "ch" )
	{
		for( new i = 0; i < count; i++ )
		{
			if( is_user_connected( players[ i ] ) )
			{
				message_begin( MSG_ONE_UNRELIABLE, get_user_msgid( "SayText" ), _, players[ i ] )
				write_byte( players[ i ] )
				write_string( msg )
				message_end( )
			}
		}
	}
}

//#pragma semicolon	1
