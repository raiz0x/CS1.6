/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <fakemeta>
#include <xs>
#include <cstrike>

#define PLUGIN "Coin Challenge Game"
#define VERSION "1.0"
#define AUTHOR "Natsheh"

#define get_user_money(%1) cs_get_user_money(%1)
#define set_user_money(%1,%2) cs_set_user_money(%1,%2)

public plugin_precache()
{
	precache_model("models/coin.mdl")
}

new FW_PRETHINK_POST
new user_coin_bet[33], user_incoin_challenge[33], user_coin[33];

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_clcmd("say /coin", "clcmd_stack_menu")
	register_clcmd("say_team /coin", "clcmd_stack_menu")
	
	register_clcmd("enter_coin_bet", "clcmd_coinbet")
}

public client_authorized(id)
{
	user_incoin_challenge[id] = 0;
	user_coin_bet[id] = 0;
}

public clcmd_coinbet(id)
{
	if(user_incoin_challenge[id] > 0) return 1;
	
	new szArgs[30];
	read_args(szArgs, charsmax(szArgs))
	remove_quotes(szArgs)
	
	new amount = str_to_num(szArgs);
	
	if(amount > get_user_money(id)) {
		client_print(id, print_center, "You dont have that amount of money!")
	}
	else {
		user_coin_bet[id] = amount;
	}
	
	clcmd_stack_menu(id);
	return 1;
}

public clcmd_stack_menu(id)
{
	if(user_incoin_challenge[id] > 0) return 1;
	
	new menu = menu_create("\rCoin Challenge^n\yChoose your stack!", "coin_menu_handle");
	
	new szText[32]
	formatex(szText, charsmax(szText), "\wChoose your Stack: \r%d$^n^n", user_coin_bet[id])
	menu_additem(menu, szText, "STACK")
	menu_additem(menu, "\rReady!", "STACK")
	
	menu_display(id, menu)
	return 1;
}

public clclmd_coin_menu(id)
{
	if(user_coin_bet[id] <= 0)
	{
		clcmd_stack_menu(id)
		client_print(id, print_center, "Choose your stack!")
		return PLUGIN_HANDLED;
	}
	
	new menu = menu_create("\rCoin Challenge^n\yChoose your opponent!", "coin_menu_handle");
	
	new players[32], pnum;
	get_players(players, pnum, "ch")
	
	if(pnum <= 1 || user_incoin_challenge[id] > 0)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	for(new i, szName[32], player, szInfo[3]; i < pnum; i++)
	{
		player = players[i];
		if(player == id || user_incoin_challenge[player] > 0) continue;
		get_user_name(player, szName, charsmax(szName))
		num_to_str(player, szInfo, charsmax(szInfo))
		menu_additem(menu, szName, szInfo)
	}
	
	menu_display(id, menu)
	return PLUGIN_HANDLED;
}

public coin_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT || user_incoin_challenge[id] > 0)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new sData[12], paccess, iCallback;
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, iCallback)
	menu_destroy(menu)
	
	if(equal(sData, "STACK"))
	{
		switch( item )
		{
			case 0:
			{
				client_print(id, print_center, "Choose an amount of money above than zero!")
				client_cmd(id, "messagemode enter_coin_bet")
			}
			case 1: clclmd_coin_menu(id)
		}
		
		return PLUGIN_HANDLED;
	}
	if(equal(sData, "DUEL", 4))
	{
		strtok(sData, "", 0, sData, charsmax(sData), '|')
		new player = str_to_num(sData);
		if(!is_user_connected(player) || user_incoin_challenge[player] > 0) return PLUGIN_HANDLED;
		
		new szTargetname[32], szPlayername[32];
		get_user_name(player, szTargetname, charsmax(szTargetname))
		get_user_name(id, szPlayername, charsmax(szPlayername))
		
		switch( item )
		{
			case 0:
			{
				client_print(player, print_chat, "%s has accepted your coin challenge!", szPlayername)
				client_print(0, print_chat, "%s vs %s in coin flip challenge!", szTargetname, szPlayername)
				
				new rand = random_num(1,2);
				
				set_hudmessage(101, 236, 38, -1.0, 0.34, 0, 6.0, 4.0, _, _, -1)
				show_hudmessage(rand == 1 ? id:player, "You are Tails!")
				
				set_hudmessage(101, 236, 38, -1.0, 0.34, 0, 6.0, 4.0, _, _, -1)
				show_hudmessage(rand == 1 ? player:id, "You are Heads!")
				
				if(!get_challengers_num() && FW_PRETHINK_POST == 0)
				{
					FW_PRETHINK_POST = register_forward(FM_PlayerPreThink, "fw_client_prethink_post", 1);
				}
				
				user_coin_bet[id] = user_coin_bet[player]
				
				user_incoin_challenge[id] =  rand == 1 ? 2:1;
				user_incoin_challenge[player] =  rand == 1 ? 1:2;
				
				new chosen = random_num(1,2);
				display_coin(id, chosen)
				display_coin(player, chosen)
				
				client_print(0, print_chat, "%s is tails & %s is heads!", rand == 1 ? szPlayername:szTargetname, rand == 1 ? szTargetname:szPlayername)
			}
			case 1:
			{
				client_print(player, print_chat, "%s has denied your coin challenge!", szPlayername)
			}
		}
		return PLUGIN_HANDLED;
	}
	
	new player = str_to_num(sData);
	if(!is_user_connected(player) || user_incoin_challenge[player] > 0)
	{
		clclmd_coin_menu(id)
		return PLUGIN_HANDLED;
	}
	
	new oldmenu, newmenu;
	player_menu_info(player, oldmenu, newmenu);
	if(oldmenu > 0 || newmenu > 0)
	{
		new szTargetname[32]
		get_user_name(player, szTargetname, charsmax(szTargetname))
		client_print(id, print_center, "%s seems to be busy!", szTargetname)
		clclmd_coin_menu(id)
		return PLUGIN_HANDLED;
	}
	
	coin_menu_duel(id, player)
	return PLUGIN_HANDLED;
}

coin_menu_duel(id, target)
{
	new szText[64], szName[32]
	get_user_name(id, szName, charsmax(szName))
	formatex(szText, charsmax(szText), "\w%s has Challenged you for \r%d$^n\yIn a coin flip game!^n", szName, user_coin_bet[id])
	new menu = menu_create(szText, "coin_menu_handle");
	
	formatex(szText, charsmax(szText), "DUEL|%d", id)
	menu_additem(menu, "Accept the Challenge!^n", szText)
	menu_additem(menu, "Deny the Challenge!", szText)
	
	menu_setprop(menu, MPROP_EXIT, MEXIT_NEVER)
	
	menu_display(target, menu)
}

display_coin(target, chosen)
{
	new ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"));
	
	if(!ent) return;
	
	user_coin[target] = ent;
	
	static Float:fOrigin[3], Float:fAim[3];
	pev(target, pev_origin, fOrigin)
	pev(target, pev_view_ofs, fAim)
	xs_vec_add(fOrigin, fAim, fOrigin)
	pev(target, pev_v_angle, fAim)
	angle_vector(fAim, ANGLEVECTOR_FORWARD, fAim)
	xs_vec_mul_scalar(fAim, 10.0, fAim)
	xs_vec_add(fOrigin, fAim, fOrigin)
	pev(target, pev_v_angle, fAim)
	
	set_pev(ent, pev_classname, "coin")
	set_pev(ent, pev_movetype, MOVETYPE_NOCLIP)
	set_pev(ent, pev_solid, SOLID_NOT)
	set_pev(ent, pev_origin, fOrigin)
	set_pev(ent, pev_v_angle, fAim)
	engfunc(EngFunc_SetModel, ent, "models/coin.mdl")
	
	set_pev(ent, pev_animtime, get_gametime() + 2.0)
	set_pev(ent, pev_sequence, 1)
	set_pev(ent, pev_frame, 2.0)
	set_pev(ent, pev_framerate, 1.0)
	set_pev(ent, pev_iuser4, chosen)
	set_pev(ent, pev_iuser2, target)
	
	set_task(6.0, "task_chosen_side", ent)
}

public task_chosen_side(const ent)
{
	new classname[6]
	pev(ent, pev_classname, classname ,charsmax(classname))
	
	if(!pev_valid(ent) || !equal(classname, "coin")) return;
	
	set_pev(ent, pev_sequence, 0)
	set_pev(ent, pev_frame, 1.0)
	set_pev(ent, pev_framerate, 1.0)
	if(pev(ent, pev_iuser4) == 2) set_pev(ent, pev_iuser3, 1)
	new owner = pev(ent, pev_iuser2);
	set_task(3.0, "client_disconnect",  owner)
	
	switch(user_incoin_challenge[owner] == pev(ent, pev_iuser4)) {
		case true:{
			set_user_money(owner, (get_user_money(owner)+user_coin_bet[owner]))
			new sName[32];
			get_user_name(owner, sName, charsmax(sName))
			client_print(0, print_chat, "%s won the flip the coin game!", sName)
			
			set_hudmessage(21, 243, 13, -1.0, 0.28, 0, 6.0, 4.0, _, _, -1)
			show_hudmessage(owner, "You have Won!")
		}
		case false: 
		{
			set_user_money(owner, (get_user_money(owner)-user_coin_bet[owner]))
			set_hudmessage(243, 21, 13, -1.0, 0.28, 0, 6.0, 4.0, _, _, -1)
			show_hudmessage(owner, "You have lost!")
		}
	}
}

get_challengers_num()
{
	new players[32],pnum, count;
	get_players(players, pnum, "ch")
	for(new i; i < pnum; i++)
	{
		if(user_incoin_challenge[players[i]] > 0)
		{
			count++;
		}
	}
	return count;
}

public client_disconnect(id)
{
	user_incoin_challenge[id] = 0;
	user_coin_bet[id] = 0;
	if(user_coin[id] > 0)
	{
		engfunc(EngFunc_RemoveEntity, user_coin[id])
		user_coin[id] = 0;
		
		if(!get_challengers_num() && FW_PRETHINK_POST != 0)
		{
			unregister_forward(FM_PlayerPreThink, FW_PRETHINK_POST, 1)
			FW_PRETHINK_POST = 0;
		}
	}
}

public fw_client_prethink_post(target)
{
	static ent;
	if((ent = user_coin[target]) > 0)
	{
		static Float:fOrigin[3], Float:fAim[3];
		pev(target, pev_origin, fOrigin)
		pev(target, pev_view_ofs, fAim)
		xs_vec_add(fOrigin, fAim, fOrigin)
		pev(target, pev_v_angle, fAim)
		angle_vector(fAim, ANGLEVECTOR_FORWARD, fAim)
		xs_vec_mul_scalar(fAim, 10.0, fAim)
		xs_vec_add(fOrigin, fAim, fOrigin)
		pev(target, pev_v_angle, fAim)
		set_pev(ent, pev_origin, fOrigin)
		pev(ent, pev_angles, fOrigin)
		fAim[0] = fOrigin[0];
		fAim[2] = fOrigin[2];
		fAim[1] += 180.0;
		if(pev(ent, pev_iuser3) == 1)
		{
			fAim[1] += 180.0;
		}
		
		set_pev(ent, pev_angles, fAim)
	}
}
